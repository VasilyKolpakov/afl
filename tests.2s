# <string>
def "print_bash_escape_seq" {
    print_string
    write_byte_to_stdout 27
} ;

# <string>
def "print_green_string" {
    print_bash_escape_seq "[0m"
    print_string
    print_bash_escape_seq "[0;32m"
} ;

# <string>
def "print_red_string" {
    print_bash_escape_seq "[0m"
    print_string
    print_bash_escape_seq "[0;31m"
} ;

# <test name> <test body>
def "run_test" {
   if { call } { print_green_string "OK\n" } { print_red_string "FAIL\n" }
   print_string ": "
   print_string
} ;


# <string> ->
def "debug" {
    print_newline
    .s
    print_newline
    print_string
    print_newline
} ;

run_test "bit rshift" {
    and = 
        1
        bit_rshift 2 1
    and = 
        8
        bit_rshift 16 1
    and = 
        + 4 8
        bit_rshift + 16 32 2

        true
} ;

run_test "bit lshift" {
    and = 
        4
        bit_lshift 2 1
    and = 
        32
        bit_lshift 16 1
    and = 
        + 16 32
        bit_lshift + 4 8 2

        true
} ;

run_test "bit xor" {
    and = 
        3
        bit_xor 2 1
    and = 
        0
        bit_xor 3 3

        true
} ;

run_test "bit or" {
    and = 
        3
        bit_or 2 1
    and = 
        3
        bit_or 3 1

        true
} ;

run_test "bit and" {
    and = 
        4
        bit_and 7 4
    and = 
        1
        bit_and 3 1

        true
} ;

run_test "round_up_to_power_of_two" {
    and = 
        4
        round_up_to_power_of_two 3
    and = 
        0
        round_up_to_power_of_two 0
    and = 
        1
        round_up_to_power_of_two 1
    and = 
        128
        round_up_to_power_of_two 100

        true
} ;

# <size> -> <byte size>
def "bitset_size" { if { not = 0 dup } { + 1 / swap 8 + -1 } { 0 drop } } ;

run_test "bitset size" {
    and = 
        0
        bitset_size 0
    and =
        1
        bitset_size 4
    and =
        10
        bitset_size 75
    true
} ;

# <address> <n> -> <bit n> <byte address>
def "bitset_bit_address" {
   % swap 8 swap    # <bit n> <byte address>
   +                # <byte address> <n>
   / swap 8 over    # <address> <n> 
} ;

# <address> <n> ->
def "bitset_add" {
    write_mem_byte      # <byte address> <updated byte>
    swap bit_or         # <byte with bit> <old byte> <byte address>
    bit_lshift 1    # <bit n> <old byte> <byte address>
    swap                # <byte> <bit n> <byte address>
    read_mem_byte over  # <bit n> <byte address>
    bitset_bit_address
} ;

# <address> <n> ->
def "bitset_remove" {
    write_mem_byte      # <byte address> <updated byte>
    swap bit_and         # <byte with bitmask> <old byte> <byte address>
    bit_xor -1 bit_lshift 1    # <bit n> <old byte> <byte address>
    swap                # <byte> <bit n> <byte address>
    read_mem_byte over  # <bit n> <byte address>
    bitset_bit_address
} ;

# <address> <n> -> <bool>
def "bitset_contains" {
    = bit_and over swap   # <bit byte> <byte>
    bit_lshift 1 swap   # <byte> <bit n>
    read_mem_byte swap  # <bit n> <byte address>
    bitset_bit_address
} ;

run_test "bitset operations" {
    drop syscall_munmap r> 4096
        and
            not bitset_contains r_peek 1 0
            bitset_remove r_peek 1 0
            bitset_add r_peek 1 0
        and
            bitset_contains r_peek 1 10
            bitset_add r_peek 1 10
        and
            bitset_contains r_peek 1 8
            bitset_add r_peek 1 8
            bitset_remove r_peek 1 0
        and
            bitset_contains r_peek 1 0
            bitset_add r_peek 1 0
        and
            not bitset_contains r_peek 1 100
        true
    >r syscall_mmap_anon 4096
} ;

# <address> <n> ->
def "memzero" {
    2drop
    while { not = 0 over } {
        + 1
        swap + -1 swap
        write_mem_byte swap 0 dup
    }
} ;


run_test "memzero" {
    drop syscall_munmap r> 4096
        and
            =
                0
                read_mem_byte + 10 r_peek 1
            memzero r_peek 1 100
            write_mem_byte + 10 r_peek 1 1
        and
            and
                =
                    0
                    read_mem_byte r_peek 1
                =
                    1
                    read_mem_byte + 100 r_peek 1
            memzero r_peek 1 100
            write_mem_byte + 100 r_peek 1 1
            write_mem_byte r_peek 1 1
        and =
            1
            read_mem_byte r_peek 1
            write_mem_byte r_peek 1 1
        true
    >r syscall_mmap_anon 4096
} ;


# <byte mem size> -> <8-byte aligned byte size>
def "align_mem_size" {
    * 8 / swap 8 + 7
} ;

run_test "align_mem_size" {
    and = 
        0
        align_mem_size 0
    and = 
        8
        align_mem_size 1
    and = 
        16 
        align_mem_size 10
    true
} ;

# <free block> -> <next free block>
def "block_allocator_block_get_next_block" {
    read_mem_i64
} ;

# <free block> <next free block> ->
def "block_allocator_block_set_next_block" {
    write_mem_i64
} ;

# <page pointer> <allocator pointer> ->
def "block_allocator_page_init" {
    write_mem_i64
} ;

# <allocator pointer> -> <page pointer>
def "block_allocator_get_pointer_to_last_page" {
    read_mem_i64 + 16
} ;

# <allocator pointer> <page pointer> ->
def "block_allocator_set_pointer_to_last_page" {
    write_mem_i64 + 16
} ;

# <allocator pointer> -> <value>
def "block_allocator_get_next_unalloc_space" {
    read_mem_i64 + 24
} ;

# <allocator pointer> <value> ->
def "block_allocator_set_next_unalloc_space" {
    write_mem_i64 + 24
} ;

# <allocator pointer> -> <value>
def "block_allocator_get_block_size" {
    read_mem_i64
} ;

# <allocator pointer> <value> ->
def "block_allocator_set_block_size" {
    write_mem_i64
} ;

# <allocator pointer> -> <value>
def "block_allocator_get_pointer_to_freelist" {
    read_mem_i64 + 8
} ;

# <allocator pointer> <value> ->
def "block_allocator_set_pointer_to_freelist" {
    write_mem_i64 + 8
} ;

# <allocator> -> <bitset size>
def "block_allocator_bitset_size" {
    + 1 / swap 8 / 4096 block_allocator_get_block_size
} ;

# <allocator> -> <page header size>
def "block_allocator_page_header_size" {
    + 8 align_mem_size block_allocator_bitset_size
} ;

# <allocator pointer> -> # allocator.block_size must be initialized
def "block_allocator_alloc_new_page" {
   block_allocator_set_next_unalloc_space swap # <page header size> <alocator>
   block_allocator_page_header_size dup # <allocator>
   block_allocator_set_pointer_to_last_page -rot dup swap # <page> <allocator>
   block_allocator_page_init 2dup # init page <page> <allocator>
   syscall_mmap_anon 4096 
} ;

# <allocator> <block size>
def "block_allocator_init" {
    block_allocator_alloc_new_page # <allocator>
    block_allocator_set_pointer_to_freelist swap 0 dup # <allocator>
    block_allocator_set_block_size -rot dup
} ;

# <block> -> <page>
def "block_allocator_get_block_page" {
    - swap % swap 4096 dup
} ;

# <block> -> <allocator>
def "block_allocator_get_allocator_for_block" {
    read_mem_i64 block_allocator_get_block_page
} ;

# <block> -> <bitset>
def "block_allocator_get_block_page_index" {
    drop r>
    / swap block_allocator_get_block_size r_peek 1 # <block offset>
    - swap  # <page header size> <block page offset>
        block_allocator_page_header_size r_peek 1 # <block page offset>
    - swap block_allocator_get_block_page dup # <block>
    >r # <allocator> <block>
    block_allocator_get_allocator_for_block dup
} ;

# <block> <bool> ->
def "block_allocator_update_bitset" {
    drop r>
    if { } { bitset_add } { bitset_remove } # <bool> <bitset> <n>
    rot # <bitset> <n> <bool>
    + 8 block_allocator_get_block_page swap # <n> <block> <bool>
    block_allocator_get_block_page_index dup # <block> <bool>
    >r # <allocator> <block> <bool>
    read_mem_i64 block_allocator_get_block_page dup
} ; 

# <block> -> <bool>
def "block_allocator_check_bitset" {
    drop r>
    bitset_contains
        + 8 block_allocator_get_block_page r_peek 1
        block_allocator_get_block_page_index r_peek 1
    >r
} ;

# <allocator> -> <block>
def "block_allocator_allocate" {
    block_allocator_update_bitset swap true dup
    if { not = 0 dup } {
        block_allocator_set_pointer_to_freelist rot # <next free block> <free block> <allocator>
        block_allocator_block_get_next_block dup # <free block> <allocator>
    } {
        r>
        block_allocator_set_next_unalloc_space swap # <next nus> <allocator>
        + block_allocator_get_block_size over # <nus> <allocator>
        >r dup # <nus> <allocator>
        block_allocator_get_next_unalloc_space dup # <allocator>
        if {
            swap r>
            <=
                +
                    block_allocator_get_block_size r_peek 1
                    block_allocator_get_next_unalloc_space r_peek 1
                +
                    block_allocator_get_pointer_to_last_page r_peek 1
                    4096
            >r # <allocator>
        } { } {
            block_allocator_alloc_new_page dup
        }
        drop # <null pointer> <allocator>
    }
    block_allocator_get_pointer_to_freelist dup 
} ;

# <block> -> <bool>
def "block_allocator_free" {
    if { dup } {
        block_allocator_update_bitset swap false
        block_allocator_set_pointer_to_freelist dup # <block> <bool>
        block_allocator_block_set_next_block swap
            block_allocator_get_pointer_to_freelist r_peek 1 # <block> <block> <bool>
        dup # <block> <bool>
        >r block_allocator_get_allocator_for_block dup swap # <bool> <block>
    } { }
    block_allocator_check_bitset dup
}

# <seed> -> <scrambled seed>
def "random_initial_scramble" {
    bit_and
        - bit_lshift 1 48 1
        bit_xor 25214903917
} ;

# <seed> -> <next seed>
def "random_next_seed" {
    bit_and
        - bit_lshift 1 48 1
        + 11 * 25214903917
} ;

# <address> <seed> ->
def "random_init" {
    write_mem_i64 swap random_initial_scramble swap
} ;

# <address> -> <number>
def "random_next_int" {
    bit_and
        - bit_lshift 1 33 1
    bit_rshift swap 16
    write_mem_i64 # <address> <next seed> <next seed>
    rot dup random_next_seed # <seed> <address>
    read_mem_i64 dup
} ;

# <n> <function>
def "do_n_times" {
    2drop
    while { < 0 dup } {
        r> r> call >r dup >r + -1 
    }
} ;

run_test "block allocator" {
    true
} ;


constant "rng_instance" syscall_mmap_anon 4096 ;
random_init rng_instance 0 ;

def "rng_int32" {
    random_next_int rng_instance
} ;

constant "block_size" 1024 ;

constant "test_block_allocator"
    block_allocator_init swap block_size dup
    debug "alloc"
    syscall_mmap_anon 4096
;

constant "test_array" syscall_mmap_anon 4096 ;

constant "num_blocks" 100 ;

# <address> <byte value> <count>
def "memset" {
    2drop
    do_n_times swap {
        + 1 # <address> <byte value>
        write_mem_byte 2dup # <address> <byte value>
    }
    rot
} ;

run_test "memset" {
    drop syscall_munmap r> 4096
    and =
        42
        read_mem_byte + 99 r@
    and =
        0
        read_mem_byte + 100 r@
    and =
        42
        read_mem_byte r@
    true
    memset r@ 42 100
    >r syscall_mmap_anon 4096
} ;

def "run_test_iteration" {
    if { = 0 } {
        write_mem_i64 + test_array * 8 swap
        memset -rot block_size 2dup # <block> <R>
        block_allocator_allocate test_block_allocator # <R>
    } {
        block_allocator_free test_block_allocator
        read_mem_i64 + test_array * 8 # <R>
    }
    # <block or 0> <R>
    read_mem_i64 + test_array * 8 dup # <R>
    % rng_int32 num_blocks
} ;

def "check_test_array" {
    do_n_times num_blocks {
        if { = 0 dup } {
            drop
        } {
            do_n_times block_size {
                + 1
                if { not = over } {
                    exit 1
                    print_string "bad block"
                } { } # <byte> <array index> <address>
                read_mem_byte over # <array index> <address>
            }
            swap
        } # <block> <array index>
        read_mem_i64 + test_array * 8 dup # <array index>
    }
    0
} ;

print_string "===================================\n" ;
do_n_times 10 {
    check_test_array run_test_iteration
} ;

.s ;

exit 0 ;
