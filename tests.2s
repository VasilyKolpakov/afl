# <string>
def "print_bash_escape_seq" {
    print_string
    write_byte_to_stdout 27
} ;

# <string>
def "print_green_string" {
    print_bash_escape_seq "[0m"
    print_string
    print_bash_escape_seq "[0;32m"
} ;

# <string>
def "print_red_string" {
    print_bash_escape_seq "[0m"
    print_string
    print_bash_escape_seq "[0;31m"
} ;

# <test name> <test body>
def "run_test" {
   if { i } { print_green_string "OK\n" } { print_red_string "FAIL\n" }
   print_string ": "
   print_string
} ;


run_test "bit rshift" {
    and = 
        1
        bit_rshift 2 1
    and = 
        8
        bit_rshift 16 1
    and = 
        + 4 8
        bit_rshift + 16 32 2

        true
} ;

run_test "bit lshift" {
    and = 
        4
        bit_lshift 2 1
    and = 
        32
        bit_lshift 16 1
    and = 
        + 16 32
        bit_lshift + 4 8 2

        true
} ;

run_test "bit xor" {
    and = 
        3
        bit_xor 2 1
    and = 
        0
        bit_xor 3 3

        true
} ;

run_test "bit or" {
    and = 
        3
        bit_or 2 1
    and = 
        3
        bit_or 3 1

        true
} ;

run_test "bit and" {
    and = 
        4
        bit_and 7 4
    and = 
        1
        bit_and 3 1

        true
} ;

run_test "round_up_to_power_of_two" {
    and = 
        4
        round_up_to_power_of_two 3
    and = 
        0
        round_up_to_power_of_two 0
    and = 
        1
        round_up_to_power_of_two 1
    and = 
        128
        round_up_to_power_of_two 100

        true
} ;

# <size> -> <byte size>
def "bitset_size" { if { not = 0 dup } { + 1 / swap 8 + -1 } { 0 drop } } ;

run_test "bitset size" {
    and = 
        0
        bitset_size 0
    and =
        1
        bitset_size 4
    and =
        10
        bitset_size 75
    true
} ;

# <address> <n> -> <bit n> <byte address>
def "bitset_bit_address" {
   % swap 8 swap    # <bit n> <byte address>
   +                # <byte address> <n>
   / swap 8 over    # <address> <n> 
} ;

# <address> <n> ->
def "bitset_add" {
    write_mem_byte      # <byte address> <updated byte>
    swap bit_or         # <byte with bit> <old byte> <byte address>
    bit_lshift 1    # <bit n> <old byte> <byte address>
    swap                # <byte> <bit n> <byte address>
    read_mem_byte over  # <bit n> <byte address>
    bitset_bit_address
} ;

# <address> <n> ->
def "bitset_remove" {
    write_mem_byte      # <byte address> <updated byte>
    swap bit_and         # <byte with bitmask> <old byte> <byte address>
    bit_xor -1 bit_lshift 1    # <bit n> <old byte> <byte address>
    swap                # <byte> <bit n> <byte address>
    read_mem_byte over  # <bit n> <byte address>
    bitset_bit_address
} ;

# <address> <n> -> <bool>
def "bitset_contains" {
    = bit_and over swap   # <bit byte> <byte>
    bit_lshift 1 swap   # <byte> <bit n>
    read_mem_byte swap  # <bit n> <byte address>
    bitset_bit_address
} ;

run_test "bitset operations" {
    drop syscall_munmap r> 4096
        and
            not bitset_contains r_peek 1 0
            bitset_remove r_peek 1 0
            bitset_add r_peek 1 0
        and
            bitset_contains r_peek 1 10
            bitset_add r_peek 1 10
        and
            bitset_contains r_peek 1 8
            bitset_add r_peek 1 8
            bitset_remove r_peek 1 0
        and
            bitset_contains r_peek 1 0
            bitset_add r_peek 1 0
        and
            not bitset_contains r_peek 1 100
        true
    >r syscall_mmap_anon 4096
} ;

.s ;

exit 0 ;
