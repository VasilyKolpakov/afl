r "r" "rename_word" ;

rename_word "d" "def" ;

rename_word "i" "call" ;
rename_word "w" "while" ;
rename_word "cs" "cond_start" ;
rename_word "ce" "cond_end" ;
rename_word "cw" "cond_when" ;
rename_word "cd" "cond_default" ;
rename_word "t" "true" ;
rename_word "f" "false" ;

rename_word "b&" "and" ;
rename_word "b|" "or" ;
rename_word "b!" "not" ;

rename_word ">>" "bit_rshift";
rename_word "<<" "bit_lshift";
rename_word "^" "bit_xor";
rename_word "|" "bit_or";
rename_word "&" "bit_and";

rename_word "nl" "print_newline" ;
rename_word "p" "print_string" ;
rename_word ".b" "print_bool" ;
rename_word ".c" "write_byte_to_stdout" ;


rename_word "du" "dup" ;
rename_word "dn" "pick" ;
rename_word "2d" "2dup" ;
rename_word "s" "swap" ;
rename_word "ro" "rot" ;
rename_word "rr" "-rot" ;
rename_word "dr" "drop" ;
rename_word "o" "over" ;
def "2drop" { drop drop } ;

rename_word "rd" "return_stack_depth" ;

rename_word "rp" "r_pick" ;

rename_word "wb" "write_mem_byte" ;
rename_word "rb" "read_mem_byte" ;
rename_word "wi" "write_mem_i64" ;
rename_word "ri" "read_mem_i64" ;

rename_word "sc" "syscall" ;

rename_word "di" "the_dictionary" ;

rename_word "fc" "func_compose" ; # <func1> <func2> -> <func that calls func2 first, then call func1>
rename_word "ca" "func_capture" ; # <value> -> <func that puts value on the stack>

rename_word "hp" "sigsegv_handler_pointer"

# <name> <value> ->
def "constant" {
    def swap func_capture swap
} ;

constant "return_instruction_code" read_mem_i64 { } ;

# <string> ->
def "debug" {
    print_newline .s print_newline print_string print_newline
} ;

