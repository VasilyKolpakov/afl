# import lib.2s
# import buffered_stdin.2s
# import byte_vector.2s
# import stack_effect.2s

# <size> <pointer 1> <pointer 2> -> <-1 or 0 or 1>
def "memcmp" {
    dip { 2drop } drop
    while { and bi* { < 0 } { = 0 } 2dup } { # while size > 0 and result = 0
        + -1 2dip { bi@ { + 1 } } # advance pointers and decrement size
        dip {
            compare_i64 bi@ { read_mem_byte } 2dup
            drop
        }
    }
    # <size> <cmp result> <p1> <p2>
    dip { 0 }
} ;

# <str 1> <str 2> -> <bool>
def "string_equals" {
    if { = bi@ { byte_vector_get_size } 2dup } {
        = 0 memcmp
        dip { bi@ { byte_vector_get_array } }
        byte_vector_get_size dup
    } { false 2drop }
} ;

# <word name> -> <bool>
def "is_word_exists" {
    dip { drop } drop
    while { lazy_and { not = 0 dup } not over } {
        stacktrace_dict_record_next
        keep { string_equals stacktrace_dict_record_name dip { dup } }
        dip { drop }
    }
    stacktrace_def_list false
} ;

# <name> <func> ->
def "shadow_def" {
    write_mem_i64 the_dictionary
    keep { write_mem_i64 + 16 dip { stacktrace_def_list } } # next
    keep { write_mem_i64 } # name
    keep { write_mem_i64 + 8 } # word_def
    malloc 24
    keep { write_mem_i64 + 8 dip { true } } # is_function = true
    keep { write_mem_i64 }
    malloc 16
    swap
} ;

# <name> <func> ->
shadow_def "def" {
    debug "in def"
    shadow_def
    if { is_word_exists dup } {
        exit 1
        print_newline
        print_string "' is already defined"
        print_string dup
        print_string "word '"
    } { }
    print_newline
    print_string dup
    print_string "defining "
} ;

# <name> <value> ->
shadow_def "constant" {
    def swap func_capture swap
} ;

def "print_char_ord" {
    print_newline
    . read_mem_byte read_mem_i64 + 16
    print_string "' is " print_string dup print_string "char '"
} ;

print_char_ord ";" ;
print_char_ord " " ;
print_char_ord "{" ;
print_char_ord "}" ;
print_char_ord "\t" ;
print_char_ord "\n" ;

def "skip_whitespace" {
    drop
    while { lazy_or { lazy_or { = 9 dup } = 10 dup } = 32 dup } {
        buffered_stdin_peek_byte
        drop buffered_stdin_read_byte drop
    }
    buffered_stdin_peek_byte
} ;

# -> <token string>
def "read_raw_token" {
    drop swap
    while { not lazy_or { lazy_or { = 9 over } = 10 over } = 32 over } {
        dip { buffered_stdin_peek_byte }
        drop buffered_stdin_read_byte
        keep { byte_vector_append }
    }
    byte_vector_new
    buffered_stdin_peek_byte
    skip_whitespace
} ;


# token layout
# [type id] [value]
# types:
# 0 - {{ 
# 1 - }} 
# 2 - {
# 3 - }
# 4 - string literal, value is string
# 5 - char literal, value is byte
# 6 - word or i64 literal, value is string
# 7 - ;

# <expr type id> <value> -> <token>
def "token_create" {
    keep { write_mem_i64 + 8 }
    keep { write_mem_i64 }
    malloc * 2 8
} ;
 
# <expr> -> <token type id>
def "token_get_type_id" {
    read_mem_i64
} ;

# <expr> -> <value>
def "token_get_value" {
    read_mem_i64 + 8
} ;

# <token> ->
def "token_print" {
    cond_end
    cond_default { assert "bad token type" false 2drop }
    cond_when { = 7 dup } { print_string "semicolon" 2drop }
    cond_when { = 6 dup } { print_string "'" print_string token_get_value print_string "word or i64 literal: '" drop }
    cond_when { = 5 dup } { print_string "'" write_byte_to_stdout token_get_value print_string "char literal: '" drop }
    cond_when { = 4 dup } { print_string "'" print_string token_get_value print_string "string literal: '" drop }
    cond_when { = 3 dup } { print_string "close paren" 2drop }
    cond_when { = 2 dup } { print_string "open paren" 2drop }
    cond_when { = 1 dup } { print_string "double close paren" 2drop }
    cond_when { = 0 dup } { print_string "double open paren" 2drop }
    cond_start
    token_get_type_id dup
} ;

def "scanner_peek" {
    buffered_stdin_peek_byte
} ;

def "scanner_advance" {
    drop buffered_stdin_read_byte
} ;

def "char" {
    byte_vector_get dip { 0 }
} ;

# -> <token>
def "read_next_token" {
    if { = scanner_peek }
    skip_whitespace
} ;

# expression layout
# [type id] [value]
# types:
# 0 - quoted expressions {{ }}, value is expression list
# 1 - anon function { }, value is expression list
# 2 - i64 literal, value is i64
# 3 - string literal, value is string
# 4 - char literal, value is byte
# 5 - word, value is string

print_newline . return_stack_depth print_string "ret stack depth: " ;

# <expr type id> <value> -> <expression>
def "expression_create" {
    keep { write_mem_i64 + 8 }
    keep { write_mem_i64 }
    malloc * 2 8
} ;

 
# <expr> -> <token type id>
def "expression_get_type_id" {
    read_mem_i64
} ;

# <expr> -> <value>
def "expression_get_value" {
    read_mem_i64 + 8
} ;


se_check_last_defined_function ;

# <token> ->
def "expression_print" {
    cond_end
    cond_default { assert "bad expression type" false 2drop }
    cond_when { = 5 dup } { print_string expression_get_value drop }
    cond_start
    expression_get_type_id dup
} ;


print_string "after\n" ;

token_print token_create 7 0 ;
print_newline . char " " ;
print_newline . char "\t" ;
print_newline . char "\n" ;
exit 0 ;
