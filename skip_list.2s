# import syscalls.2s
# import allocator.2s

# <addr> <n> ->
def "print_mem" {
    drop
    do_n_times swap {
        + 8
        print_string " "
        . read_mem_i64 dup
    }
    swap
} ;

# <left> <right> -> <ordering>
def "compare_list_values" {
    if { > 2dup } {
        2drop 1
    } { 
        if { < } {
            -1
        } {
            0
        }
    }
} ;

# <bool func> <bool> -> <bool>
def "lazy_and" {
    if { not } {
        false
    }
} ;

# <size> -> <buffer>
def "calloc" {
    memzero over swap # <buffer> <size>
    malloc dup
} ;

constant "rng_instance" syscall_mmap_anon 4096 ;
random_init rng_instance 120 ;

def "random_bool" {
    = 0 % swap 2 random_next_int rng_instance
} ;

def "random_int32" { random_next_int rng_instance } ;

def "skip_list_random_level" {
    while { random_bool } { + 1 } 0
} ;

# skip list node layout:
# [level][key][value][level 0 next][level 1 next] ...

# <level> -> <size>
def "skip_list_node_size" {
    + 24 * 8 + 1
} ;

# <key> <value> -> <node>
def "skip_list_node_create" {
    keep { write_mem_i64 + 16 }
    keep { write_mem_i64 + 8 }
    keep { write_mem_i64 }
    calloc skip_list_node_size dup skip_list_random_level 
} ;

# <node> -> <key>
def "skip_list_node_get_key" {
    read_mem_i64 + 8
} ;

# <node> -> <value>
def "skip_list_node_get_value" {
    read_mem_i64 + 16
} ;

# <node> <level> ->
def "skip_list_node_set_level" {
    write_mem_i64
} ;

# <node> -> <level>
def "skip_list_node_get_level" {
    read_mem_i64
} ;

# <level> <node> -> <next node>
def "skip_list_node_get_next" {
    read_mem_i64 + # <next offset> <node>
    + 24 * 8
} ;

# <level> <node> <next node> ->
def "skip_list_node_set_next" {
    write_mem_i64 + # <next offset> <node> <next node>
    + 24 * 8
} ;

# sentinel node layout:
# [level][42][13][level 0 next][level 1 next] ...

# <level> -> <node>
def "create_sentinel_node" {
    keep { write_mem_i64 swap 13 + 16 }
    keep { write_mem_i64 swap 42 + 8 }
    keep { write_mem_i64 } # <node> <level>
    calloc skip_list_node_size dup
} ;

# skip list layout
# [sentinel node]
def "skip_list_create" {
    write_mem_i64 swap create_sentinel_node 0 dup
    malloc 8
} ;

def "skip_list_get_sentinel_node" {
    read_mem_i64
} ;

def "debug_print_skip_list_node" {
    print_string " }"
    . % swap 100000
    print_string ", addr: "
    . skip_list_node_get_level dup 
    print_string ", level: "
    . skip_list_node_get_value dup
    print_string ", value: "
    . skip_list_node_get_key dup
    print_string "{ key: "
} ;

# <s node> -> 
def "debug_print_skip_list_s_node" {
    2drop
    while { <= 0 dup } {
        + -1
        dip { drop }
        print_string "NULL\n"
        while { not = 0 skip_list_node_get_next 2dup } {
            print_string " -> "
            keep { debug_print_skip_list_node dup skip_list_node_get_next }
        }
        print_string ", S -> "
        . dup
        print_string "level: "
        dip { dup }
    }
    dip { print_newline . print_string "S addr: " dup }
    # <level> <s node>
    skip_list_node_get_level dup
} ;

# <skip list> ->
def "debug_print_skip_list" {
    debug_print_skip_list_s_node skip_list_get_sentinel_node
} ;

# <skip list> -> <level>
def "skip_list_get_max_level" {
    skip_list_node_get_level skip_list_get_sentinel_node
} ;

# <skip list> <level> -> 
def "skip_list_set_max_level" {
    skip_list_node_set_level swap # <level> <new s node>
    drop
    while { <= 2dup } {
        + 1
        swap
        dip { skip_list_node_set_next 2dip { 0 } 2dup } # <level> <old level + n> <new s node> # set next to NULL
        swap
    }
    + 1 # <old level> <level> <new s node>
    skip_list_node_get_level over # <level> <new s node>
    dip { keep { write_mem_i64 swap } } # <level> <new s node> <list> # set new s node
    dip { realloc swap } # <level> <new s node size> <s node> <list>
    keep { skip_list_node_size } # <level> <s node> <list>
    dip { read_mem_i64 dup } # <level> <list>
    swap
} ;

# <skip list> <level>
def "skip_list_update_level_if_less_than" {
    if { < } {
        skip_list_set_max_level
    } { 2drop }
    skip_list_get_max_level 2dup
} ;

def "is_neg" { > 0 } ;

# <level> <node> <key> -> <bool> <node>
def "skip_list_node_skip_one_less_than" {
    if { = 0 dup } {
        false 0 2drop
    } {
        if { is_neg compare_list_values skip_list_node_get_key over swap } {
            true
        } {
            false
        }
    }
    # <next node> <key>
    skip_list_node_get_next
} ;

# <level> <node> <key> -> <node>
def "skip_list_node_skip_all_less_than" {
    dip { 2drop }
    while { } {
        keep { drop if { } { swap } { } } # <bool> <node> <prev node> <level> <key>
        skip_list_node_skip_one_less_than swap 3dup
    } true # <node> <level> <key>
    swap
} ;

# <level> <node before> <key>
def "skip_list_node_delete_next_if_next_key_is_equal_to" {
    if { = 0 skip_list_node_get_next 2dup } {
        3drop # <level> <node> <key>
    } {
        if { = 0 compare_list_values skip_list_node_get_key skip_list_node_get_next 3dup } {
            # free memory, node was deleted on all levels on this point
            if { = 0 } { free } { drop } # <level> <node to delete>
            keep { skip_list_node_set_next }  # <level> <node> <node after deleted> <node to delete>
            2dip { skip_list_node_get_next }  # <level> <node> <level> <node to delete> <node to delete>
            2keep { keep { dup skip_list_node_get_next } } # <level> <node>
            2dip { drop }
        } {
            3drop
        }
    }
} ;

# <level> <node for insert> <new node> ->
def "skip_list_node_insert_on_level" {
    if { <= over skip_list_node_get_level pick 3 } {
        skip_list_node_set_next # <level> <node for i> <new node>
        skip_list_node_set_next # <level> <new node> <prev next node> ...
        keep { swap skip_list_node_get_next } 3dup
    } { 3drop }
    skip_list_node_delete_next_if_next_key_is_equal_to 2dip { skip_list_node_get_key } 3dup
} ;

# <skip list> ->
def "skip_list_update_level_after_delete" {
    drop # <s node>
    skip_list_set_max_level rot # <actual level> <s node> <list>
    while { = 0 skip_list_node_get_next 2dup } {
        + -1
    } # <level> <s node> <list>
    skip_list_node_get_level dup # <s node> <list>
    skip_list_get_sentinel_node dup
} ;

# <skip list> <key> <value> -> 
def "skip_list_insert" {
    skip_list_update_level_after_delete # <skip list>
    3drop
    while { <= 0 dup } {
        + -1
        skip_list_node_insert_on_level 3dup # <level> <node for insert> <new node> ...
        keep { skip_list_node_skip_all_less_than } # <level> <node> <key> <new node> ...
        2dip { skip_list_node_get_key dup }
    }
    # <list level> <s node> <value node> <skip list>
    skip_list_node_get_level dup
    skip_list_get_sentinel_node over swap # <skip list> <new node>
    skip_list_update_level_if_less_than dip { skip_list_node_get_level } 2dup # <skip list> <new node>
    dip { skip_list_node_create }
} ;

# <skip list> <key> -> <bool> <value>
def "skip_list_find" {
    if { lazy_and { = 0 compare_list_values skip_list_node_get_key over } not = 0 over } {
        true skip_list_node_get_value
    } {
        false
    }
    # <key> <node>
    swap skip_list_node_get_next 0 drop
    while { <= 0 dup } {
        + -1
        keep { skip_list_node_skip_all_less_than } # <level> <node> <key> <key>
        2dip { dup }
    } # <level> <s node> <key>
    skip_list_node_get_level dup # <s node> <key>
    skip_list_get_sentinel_node
} ;

constant "test_list" skip_list_create ;
skip_list_insert test_list 1 2 ; 
skip_list_insert test_list 1 2 ; 
skip_list_insert test_list 1 2 ; 
skip_list_insert test_list 3 6 ; 
skip_list_insert test_list 1 2 ; 
skip_list_insert test_list 1 2 ; 
skip_list_insert test_list 1 2 ; 
print_newline . print_string " "  print_bool skip_list_find test_list 1 print_string "found value: "
#debug_print_skip_list test_list ;
#do_n_times 10 {
    #skip_list_insert test_list % swap 100 random_int32 666 
#} ;
debug_print_skip_list test_list ;
.s ;
exit 0 ;
