# import stack_effect.2s

# code_buffer is a "wrapper" of array_list

def "code_buffer_new" {
    array_list_new
} ;

# <code buffer> <func>
def "code_buffer_emit_call" {
    array_list_append
    keep { array_list_append swap call_instruction_code }
} ;

# <code buffer> <value>
def "code_buffer_emit_literal" {
    array_list_append
    keep { array_list_append swap lit_instruction_code }
} ;

# <code buffer>
def "code_buffer_make_function_and_destroy" {
    array_list_destroy
    keep {
        +
        # <first instruction byte index> <ptr>
        * 8 + -1 array_list_get_size
    }
    # <cb> <ptr>
    write_mem_i64 + over
    # <func size> <ptr> ...
    * 8 array_list_get_size
    2dup
    # <cb> <ptr>
    drop swap
    drop while { < 0 dup } {
        2keep {
            keep { write_mem_i64 } swap
            # <data> <ptr>
            array_list_get swap
        }
        # <cb index> <cb> <ptr> <original ptr>
        + -1 2dip { + 8 }
    } array_list_get_size dup
    # <cb> <ptr> <ptr>
    keep { + -8 dup malloc * 8 + 1 array_list_get_size }
    bi { array_list_set 2dip { jmp_instruction_code } } { + -2 array_list_get_size } dup
    assert "last instruction is a call" = call_instruction_code bi { array_list_get } { + -2 array_list_get_size } dup
} ;
se_check_last_defined_function ;

