# import byte_vector.2s
# import array_list.2s
# import stack_effect.2s
# import switch_stmt.2s
# import lib.2s
# import code_buffer.2s
# import i64_to_text.2s
# import print_function.2s

#se_enable ;

# <string> -> <nts>
def "string_to_nts" {
    drop swap
    write_mem_byte swap 0 + byte_vector_get_size swap 2dup
    memcopy bi { byte_vector_get_size } { byte_vector_get_array } swap 2dup
    malloc + 1 byte_vector_get_size dup
} ;
se_check_last_defined_function ;

# <nst> ->
def "print_nts" {
    drop while { not = 0 read_mem_byte dup } {
        + 1
        write_byte_to_stdout read_mem_byte dup
    }
} ;

# <filename string> -> <fd>
def "open_file" {
    free
    keep {
        panic_on_syscall_error syscall_open dip { syscall_open_O_RDONLY 0 }
    }
    string_to_nts
} ;

constant "buffered_input_array_size" 1000 ;

# buffered input layout
# [input size] [index] [array] [file descriptor] [filename]
# <fd> <filename> -> <buf input>
def "buffered_input_create" {
    keep { buffered_input_set_col_number swap 0 }
    keep { buffered_input_set_line_number swap 1 }
    keep { write_mem_i64 + 32 } 
    keep { write_mem_i64 + 24 } 
    keep { write_mem_i64 + 16 swap malloc buffered_input_array_size } 
    keep { write_mem_i64 + 8 swap 0 } 
    keep { write_mem_i64 swap -1 } 
    malloc * 4 8
} ;

def "buffered_input_input_size" { read_mem_i64 } ;
def "buffered_input_set_input_size" { write_mem_i64 } ;
def "buffered_input_index" { read_mem_i64 + 8 } ;
def "buffered_input_set_index" { write_mem_i64 + 8 } ;
def "buffered_input_array" { read_mem_i64 + 16 } ;
def "buffered_input_fd" { read_mem_i64 + 24 } ;
def "buffered_input_filename" { read_mem_i64 + 32 } ;
def "buffered_input_line_number" { read_mem_i64 + 40 } ;
def "buffered_input_set_line_number" { write_mem_i64 + 40 } ;
def "buffered_input_col_number" { read_mem_i64 + 48 } ;
def "buffered_input_set_col_number" { write_mem_i64 + 48 } ;

# <bufin> -> <byte>
def "buffered_input_read_current_byte" {
    read_mem_byte + bi { buffered_input_index } { buffered_input_array }
    assert "buffered_input has not reached EOF" not = 0 buffered_input_input_size dup
    if { = -1 buffered_input_input_size dup } {
        buffered_input_advance dup # lazy init
    } { }
} ;
se_check_last_defined_function ;

# <bufin> ->
def "buffered_input_advance" {
    if { lazy_and { = newline_char buffered_input_read_current_byte dup } not buffered_input_is_eof dup } {
        buffered_input_set_col_number swap 0
        keep { bi { buffered_input_set_line_number } { + 1 buffered_input_line_number } }
    } { 
        bi { buffered_input_set_col_number } { + 1 buffered_input_col_number }
    }
    if { < bi { + 1 buffered_input_index } { buffered_input_input_size } dup } {
        bi { buffered_input_set_index } { + 1 buffered_input_index }
    } {
        buffered_input_set_index swap 0
        keep { buffered_input_set_input_size } swap
        # <bytes read> <bufin>
        panic_on_syscall_error syscall_read bi { buffered_input_fd } { buffered_input_array }
        # <bufin> <size> <bufin>
        swap buffered_input_array_size dup
    }
    dup
    assert "buffered_input has not reached EOF" not = 0 buffered_input_input_size dup
} ;
se_check_last_defined_function ;

def "buffered_input_is_eof" {
    = 0 buffered_input_input_size
    if { = -1 buffered_input_input_size dup } {
        buffered_input_advance dup # lazy init
    } { }
} ;

# <bufin> ->
def "buffered_input_close_fd_and_destroy" {
    free
    # filename strings can be used in syntax error reporting even after the file is closed
    # it is easier to just not destroy them
    #byte_vector_destroy buffered_input_filename dup
    free buffered_input_array dup
    drop panic_on_syscall_error syscall_close buffered_input_fd dup
} ;
se_check_last_defined_function ;

# <buffer> <length> -> <stirng>
def "string_from_buffer" {
    keep { memcopy rot swap byte_vector_get_array }
    keep { byte_vector_set_size dip { over } }
    keep { byte_vector_set_array dip { malloc over } }
    malloc byte_vector_struct_size
} ;
se_check_last_defined_function ;

constant "imports_list" array_list_new ;

# <string> -> <bool>
def "imports_list_contains_string" {
    drop swap
    > array_list_get_size imports_list
    while { lazy_and { not string_equals array_list_get imports_list 2dup } > array_list_get_size imports_list dup } {
        + 1
    } 0
} ;
se_check_last_defined_function ;

# <string> -> <bool> # add string to the list if it is not there yet and returns true if string was added
def "imports_list_add" {
    if { imports_list_contains_string dup } {
        false drop
    } {
        true array_list_append imports_list
    }
} ;
se_check_last_defined_function ;

constant "source_file_input_stack" array_list_new ;

# <filename string> ->
def "source_file_input_stack_push_file" {
    array_list_append source_file_input_stack buffered_input_create open_file dup
} ;
se_check_last_defined_function ;
array_list_append source_file_input_stack buffered_input_create 0 "stdin" ;

# -> <next byte or -1 if EOF>
def "scanner_peek" {
    if { array_list_is_empty source_file_input_stack } {
        -1
    } { 
        buffered_input_read_current_byte array_list_get_last source_file_input_stack
    }
} ;
se_check_last_defined_function ;

def "scanner_advance" {
    while {
        lazy_and { buffered_input_is_eof buffered_input_advance dup array_list_get_last source_file_input_stack }
        not array_list_is_empty source_file_input_stack
    } { 
        buffered_input_close_fd_and_destroy array_list_pop_last source_file_input_stack
    }
} ;
se_check_last_defined_function ;

def "scanner_current_filename" {
    buffered_input_filename array_list_get_last source_file_input_stack 
} ;
se_check_last_defined_function ;

def "scanner_current_line_number" {
    buffered_input_line_number array_list_get_last source_file_input_stack 
} ;
se_check_last_defined_function ;

def "scanner_current_col_number" {
    buffered_input_col_number array_list_get_last source_file_input_stack 
} ;
se_check_last_defined_function ;

def "scanner_print_current_position" {
    . scanner_current_col_number
    print_string ":"
    . scanner_current_line_number
    print_string ": "
    print_string scanner_current_filename
} ;

def "string_first_char" {
    byte_vector_get dip { 0 }
} ;
se_check_last_defined_function ;

constant "open_paren_char" string_first_char "(" ;
constant "close_paren_char" string_first_char ")" ;
constant "open_bracket_char" string_first_char "[" ;
constant "close_bracket_char" string_first_char "]" ;
constant "open_curly_bracket_char" string_first_char "{" ;
constant "close_curly_bracket_char" string_first_char "}" ;
constant "space_char" string_first_char " " ;
constant "t_char" string_first_char "t" ;
constant "n_char" string_first_char "n" ;
constant "x_char" string_first_char "x" ;
constant "tab_char" string_first_char "\t" ;
constant "hash_char" string_first_char "#" ;
constant "newline_char" string_first_char "\n" ;
constant "semicolon_char" string_first_char ";" ;
constant "double_quote_char" 34 ;
constant "single_quote_char" 39 ;
constant "backquote_char" string_first_char "`" ;
constant "backslash_char" 92 ;
constant "comma_char" string_first_char "," ;

# <char> -> <bool>
def "is_escape_char" {
    drop swap
    lazy_or { = double_quote_char dup }
    lazy_or { = backslash_char dup }
    lazy_or { = tab_char dup }
              = newline_char dup
} ;
se_check_last_defined_function ;

# <char> -> <char>
def "escape_string_literal_char"
    when { = tab_char dup } then { t_char drop } otherwise
    when { = newline_char dup } then { n_char drop } otherwise
    when { = backslash_char dup } then { backslash_char drop } otherwise
    when { = double_quote_char dup } then { double_quote_char drop } otherwise
    { 
        0
        assert "escapable char" false
        print_newline
        write_byte_to_stdout single_quote_char
        write_byte_to_stdout
        write_byte_to_stdout backslash_char
        write_byte_to_stdout single_quote_char
        print_string "bad escapable char: "
    }
;
se_check_last_defined_function ;

# <char> -> <char>
def "unescape_string_literal_char"
    when { = t_char dup } then { tab_char drop } otherwise
    when { = n_char dup } then { newline_char drop } otherwise
    when { = backslash_char dup } then { backslash_char drop } otherwise
    when { = double_quote_char dup } then { double_quote_char drop } otherwise
    { 
        0
        assert "correct escape sequence" false
        print_newline
        write_byte_to_stdout
        write_byte_to_stdout backslash_char
        print_string "bad escape sequence: "
    }
;
se_check_last_defined_function ;

# <char> -> <bool>
def "is_whitespace_char" {
    drop swap
    lazy_or { lazy_or { = space_char dup } = tab_char dup } = newline_char dup
} ;

def "is_paren_char" {
    drop swap
    lazy_or { = close_curly_bracket_char dup }
    lazy_or { = open_curly_bracket_char dup }
    lazy_or { = close_bracket_char dup }
    lazy_or { = open_bracket_char dup }
    lazy_or { = close_paren_char dup }
              = open_paren_char dup
} ;

def "skip_whitespace_and_comments" {
    while { lazy_or { = semicolon_char scanner_peek } is_whitespace_char scanner_peek } {
        if { = semicolon_char scanner_peek } {
            while { not = newline_char scanner_peek } { # skip line comment
                scanner_advance
            }
        } {
            scanner_advance # skip whitespace
        }
    }
} ;

constant "token_EOF_type"                  -1 ;
constant "token_open_paren_type"            0 ;
constant "token_close_paren_type"           1 ;
constant "token_open_bracket_type"          2 ;
constant "token_close_bracket_type"         3 ;
constant "token_open_curly_bracket_type"    4 ;
constant "token_close_curly_bracket_type"   5 ;
constant "token_symbol_or_i64_literal_type" 6 ;
constant "token_string_literal_type"        7 ;
constant "token_char_literal_type"          8 ;
constant "token_single_quote_type"          9 ;
constant "token_comma_type"                 10 ;

def "token_open_paren_couterpart_type"
    when { = token_open_paren_type dup } then { token_close_paren_type drop } otherwise
    when { = token_open_bracket_type dup } then { token_close_bracket_type drop } otherwise
    when { = token_open_curly_bracket_type dup } then { token_close_curly_bracket_type drop } otherwise
    { 0 . assert "not an open paren (bracket) token: " false }
 ;

# <token> -> <bool>
def "token_is_close_paren_type" {
    drop swap
    lazy_or { = token_close_curly_bracket_type dup }
    lazy_or { = token_close_bracket_type dup }
              = token_close_paren_type dup
    token_get_type_id
} ;
# <expr type id> <value> -> <token>
def "token_create" {
    keep { write_mem_i64 + 8 }
    keep { write_mem_i64 }
    malloc * 2 8
} ;
 
# <expr> -> <token type id>
def "token_get_type_id" {
    read_mem_i64
} ;

# <expr> -> <value>
def "token_get_value" {
    read_mem_i64 + 8
} ;

def "token_print_switch"
    when { = token_EOF_type dup } then { print_string "EOF" 2drop } otherwise
    when { = token_open_paren_type dup } then { print_string "open paren" 2drop } otherwise
    when { = token_close_paren_type dup } then { print_string "close paren" 2drop } otherwise
    when { = token_open_bracket_type dup } then { print_string "open bracket" 2drop } otherwise
    when { = token_close_bracket_type dup } then { print_string "close bracket" 2drop } otherwise
    when { = token_open_curly_bracket_type dup } then { print_string "open curly bracket" 2drop } otherwise
    when { = token_close_curly_bracket_type dup } then { print_string "close curly bracket" 2drop } otherwise
    when { = token_symbol_or_i64_literal_type dup } then { print_string "'" print_string token_get_value print_string "symbol or i64 literal: '" drop } otherwise
    when { = token_char_literal_type dup } then { print_string "'" print_string token_get_value print_string "char literal: '" drop } otherwise
    when { = token_string_literal_type dup } then {
        print_string "'" byte_vector_destroy print_string dup decode_string_literal print_string "decoded: '"
        print_string "', " print_string dup token_get_value
        print_string "string literal: '" drop } otherwise
    { assert "bad token type" false 2drop . dup }
;

# <token> ->
def "token_print" {
    token_print_switch
    token_get_type_id dup
} ;

def "token_destroy_switch"
    when { = token_EOF_type dup } then { free drop } otherwise
    when { = token_open_paren_type dup } then { free drop } otherwise
    when { = token_close_paren_type dup } then { free drop } otherwise
    when { = token_open_bracket_type dup } then { free drop } otherwise
    when { = token_close_bracket_type dup } then { free drop } otherwise
    when { = token_open_curly_bracket_type dup } then { free drop } otherwise
    when { = token_close_curly_bracket_type dup } then { free drop } otherwise
    when { = token_symbol_or_i64_literal_type dup } then {
        bi { free } { byte_vector_destroy token_get_value } drop
    } otherwise
    when { = token_char_literal_type dup } then {
        bi { free } { byte_vector_destroy token_get_value } drop
    } otherwise
    when { = token_string_literal_type dup } then {
        bi { free } { byte_vector_destroy token_get_value } drop
    } otherwise
    { assert "bad token type" false 2drop . dup }
;

# <token> ->
def "token_destroy" {
    token_destroy_switch
    token_get_type_id dup
} ;

def "read_next_token_symbol_or_number" {
    token_create token_symbol_or_i64_literal_type
    while {
            lazy_and { not = comma_char scanner_peek }
            lazy_and { not is_paren_char scanner_peek }
                       not is_whitespace_char scanner_peek
    } {
        scanner_advance
        keep { byte_vector_append dip { scanner_peek } } 
    }
    byte_vector_new
} ;

def "is_double_quote_or_newline" { or bi { = double_quote_char } { = newline_char } } ;

# -> <token>
def "read_next_token_double_quote" {
    token_create token_string_literal_type
    scanner_advance
    assert "no newline in string literals" not = newline_char scanner_peek
    while { not is_double_quote_or_newline scanner_peek } {
        scanner_advance
        if { = backslash_char scanner_peek } {
            keep { byte_vector_append dip { unescape_string_literal_char scanner_peek } } 
            scanner_advance
        } {
            keep { byte_vector_append dip { scanner_peek } } 
        }
    }
    scanner_advance
    byte_vector_new
} ;

# -> <token> # scanner on the char's position
def "read_next_token_switch"
    when { = -1 scanner_peek } then {
        token_create token_EOF_type 0
        scanner_advance
    } otherwise
    when { = comma_char scanner_peek } then {
        token_create token_comma_type 0
        scanner_advance
    } otherwise
    when { = single_quote_char scanner_peek } then {
        token_create token_single_quote_type 0
        scanner_advance
    } otherwise
    when { = open_paren_char scanner_peek } then {
        token_create token_open_paren_type 0
        scanner_advance
    } otherwise
    when { = close_paren_char scanner_peek } then {
        token_create token_close_paren_type 0
        scanner_advance
    } otherwise
    when { = open_bracket_char scanner_peek } then {
        token_create token_open_bracket_type 0
        scanner_advance
    } otherwise
    when { = close_bracket_char scanner_peek } then {
        token_create token_close_bracket_type 0
        scanner_advance
    } otherwise
    when { = open_curly_bracket_char scanner_peek } then {
        token_create token_open_curly_bracket_type 0
        scanner_advance
    } otherwise
    when { = close_curly_bracket_char scanner_peek } then {
        token_create token_close_curly_bracket_type 0
        scanner_advance
    } otherwise
    when { = double_quote_char scanner_peek } then { read_next_token_double_quote } otherwise
    { read_next_token_symbol_or_number }
;

# token pos layout:
# [filename][line num][col num]

# <filename> <line num> <col num> -> <token pos>
def "token_position_create" {
    keep { write_mem_i64 + 16 }
    keep { write_mem_i64 + 8 }
    keep { write_mem_i64 }
    malloc * 8 3
} ;

def "token_positon_destroy" {
    # filename is destroyed in buffered_input_close_fd_and_destroy
    free
} ;

def "token_positon_copy" {
    keep { memcopy * 3 8 swap }
    malloc * 8 3
} ;

def "token_position_print" {
    drop
    . read_mem_i64 + 16 dup
    print_string ","
    . read_mem_i64 + 8 dup
    print_string ": "
    print_string read_mem_i64 dup
} ;
se_check_last_defined_function ;

constant "current_token_pos_ptr" malloc 8 ; 
write_mem_i64 current_token_pos_ptr 0

def "current_token_pos" {
   read_mem_i64 current_token_pos_ptr
} ;

def "current_token_pos_reset" {
    if { not array_list_is_empty source_file_input_stack } {
        write_mem_i64 current_token_pos_ptr
        token_position_create
            scanner_current_filename
            scanner_current_line_number
            scanner_current_col_number
        if { not = 0 current_token_pos } {
            token_positon_destroy current_token_pos
        } { }
    } { }
} ;
se_check_last_defined_function ;

# -> <token>
def "read_next_token" {
    read_next_token_switch
    current_token_pos_reset
    skip_whitespace_and_comments
} ;
se_check_last_defined_function ;

# <char> -> <char>
def "decode_escaped_char" 
    when { = string_first_char "t" dup } then { tab_char drop } otherwise
    when { = string_first_char "n" dup } then { newline_char drop } otherwise
    when { = double_quote_char dup } then { double_quote_char drop } otherwise
    when { = backslash_char dup } then { backslash_char drop } otherwise
    { 0 assert "no bad chars" false print_newline . }
;
# <string> -> <string>
def "decode_string_literal" {
    dip { 2drop }
    while { swap dip { > byte_vector_get_size 2dup } } {
        keep { byte_vector_append }
        dip {
            2dip { + 1 }
            if { = backslash_char dup } {
                decode_escaped_char byte_vector_get 2dup
                dip { + 1 }
                drop
            } { }
            byte_vector_get 2dup
        }
    }
    # <new string> <original string> <index>
    byte_vector_new dip { 0 }
} ;
se_check_last_defined_function ;

# Lisp objects
#
# Every object has a 8-byte header
# Object header structure: [type_id: i64][gc_marked_flag (0 or 1) i64]
#
# Types
#   symbol:
#       type_id: 0
#       structure: [length: i64][string_buffer: variable]
#   i64:
#       type_id: 1
#       structure: [value: i64]
#   pair:
#       type_id: 2
#       structure: [car: pointer][cdr: pointer]
#   nil:
#       null pointer
#
#   Symbols
#       Symbols are interned strings and are not freed by GC

constant "obj_type_names" array_list_new ;

constant "symbol_obj_type_id"       0 ;
array_list_append obj_type_names "symbol" ;
constant "i64_obj_type_id"          1 ;
array_list_append obj_type_names "i64" ;
constant "pair_obj_type_id"         2 ;
array_list_append obj_type_names "pair" ;
constant "lambda_obj_type_id"       3 ;
array_list_append obj_type_names "lambda" ;
constant "bool_obj_type_id"         4 ;
array_list_append obj_type_names "bool" ;
constant "cell_obj_type_id"         5 ;
array_list_append obj_type_names "cell" ;
constant "string_obj_type_id"       6 ;
array_list_append obj_type_names "string" ;
constant "builtin_func_obj_type_id" 7 ;
array_list_append obj_type_names "builtin_func" ;


# <type id> -> <string>
def "obj_type_name" {
    array_list_get obj_type_names
} ;

constant "obj_header_size" 16 ;

# <obj ptr> <type_id> ->
def "obj_set_type_id" {
    write_mem_i64
} ;

# <obj ptr> ->
def "obj_get_type_id" {
    read_mem_i64
} ;

# <obj ptr> <type_id> ->
def "obj_set_gc_marked_flag" {
    write_mem_i64 + 8
} ;

# <obj ptr> ->
def "obj_get_gc_marked_flag" {
    read_mem_i64 + 8
} ;

# <string> -> <symbol>
def "alloc_symbol" {
    keep {
        memcopy bi { byte_vector_get_size } { byte_vector_get_array } swap # <symbol_obj_buf ptr> <string>
        + 24
        write_mem_i64 dip { byte_vector_get_size } 2dup
        + obj_header_size
    }
    keep { write_mem_i64 swap 0 + 16 + obj_header_size }
    keep { write_mem_i64 swap false + 8 + obj_header_size }
    obj_set_type_id swap symbol_obj_type_id dup
    # <symbol ptr> <string>
    malloc + * 8 3 + obj_header_size byte_vector_get_size dup
} ;
se_check_last_defined_function ;

def "symbol_get_size" {
    read_mem_i64 + obj_header_size
} ;

def "symbol_has_binding" {
    read_mem_i64 + 8 + obj_header_size
} ;

# <symbol> <bool> -> 
def "symbol_set_binding_flag" {
    write_mem_i64 + 8 + obj_header_size
} ;

def "symbol_get_binding" {
    read_mem_i64 + 16 + obj_header_size
} ;

# <symbol> <value> -> 
def "symbol_set_binding" {
    write_mem_i64 + 16 + obj_header_size
} ;

def "symbol_get_buffer" {
    + 24 + obj_header_size
} ;


# <symbol> -> <string> 
def "symbol_get_name" {
    drop swap
    memcopy 
    bi* {
        bi { symbol_get_size } { symbol_get_buffer }
    } {
        byte_vector_get_array
    } swap 2dup
    # <string> <symbol>
    bi* { byte_vector_set_size } { symbol_get_size } 2dup
    bi* { byte_vector_ensure_capacity } { symbol_get_size } 2dup
    byte_vector_new
} ;
se_check_last_defined_function ;

# <func> <name> -> <func> <name>
def "name_anon_functions_loop_switch"
    when { pf_is_if_cond dup } then {
        name_anon_functions dip { string_concat swap " if_cond" } iptr_op_arg 2dup
    } otherwise
    when { pf_is_if_then dup } then {
        name_anon_functions dip { string_concat swap " then_branch" } iptr_op_arg 2dup
    } otherwise
    when { pf_is_if_else dup } then {
        name_anon_functions dip { string_concat swap " else_branch" } iptr_op_arg 2dup
    } otherwise
    { }
;

# <name> <func> ->
def "shadow_def" {
    write_mem_i64 the_dictionary
    keep { write_mem_i64 + 16 dip { td_def_list } } # next
    keep { write_mem_i64 } # name
    keep { write_mem_i64 + 8 } # word_def
    malloc 24
    keep { write_mem_i64 + 8 dip { true } } # is_function = true
    keep { write_mem_i64 }
    malloc 16
    swap
} ;

# <name> <func> ->
shadow_def "def" {
    shadow_def
    if { td_function_has_name dup } {
        exit 1
        print_newline
        print_string "' is already defined"
        print_string dup
        print_string "word '"
    } { }
} ;

# <func> <name> ->
def "name_anon_functions" {
    2drop
    while {
        not
        lazy_or { = jmp_instruction_code iptr_op_code dup }
        lazy_or { = indirect_jmp_instruction_code iptr_op_code dup }
        = return_instruction_code iptr_op_code dup
    } {
        iptr_next
        name_anon_functions_loop_switch
    }
    def swap 2dup
} ;
se_check_last_defined_function ;


# <symbol> <value> -> 
def "symbol_bind" {
    symbol_set_binding
    if { obj_is_lambda over } {
        # register function in the dictionary
        name_anon_functions swap bi* { string_concat "lisp: " symbol_get_name } { obj_lambda_get_function } 2dup
        # <symbol> <value>
    } { } 
    keep { symbol_set_binding_flag swap true }
    if { symbol_has_binding dup } {
        exit 1
        print_newline
        print_obj symbol_get_binding dup
        print_string " is already bound to "
        print_obj dup
        print_string "symbol "
    } { }
} ;

# <symbol> -> 
def "symbol_unbind" {
    symbol_set_binding_flag swap false
} ;

constant "symbol_list" array_list_new ;

# <symbol> <string> -> <bool>
def "symbol_name_equal" {
    if { = bi* { symbol_get_size } { byte_vector_get_size } 2dup } {
        = 0 memcmp dip { bi* { symbol_get_buffer } { byte_vector_get_array } } symbol_get_size dup
    } {
        false 2drop
    }
} ;
se_check_last_defined_function ;

# <string> -> <symbol>
def "get_or_create_symbol" {
    if { = array_list_get_size symbol_list dup } {
        array_list_append symbol_list dup alloc_symbol drop
    } {
        array_list_get symbol_list dip { drop }
    }
    while { lazy_and { not symbol_name_equal array_list_get symbol_list 2dup } > array_list_get_size symbol_list dup } {
        + 1
    }
    0
} ;
se_check_last_defined_function ;

# <number> -> <obj>
def "alloc_i64" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap i64_obj_type_id }
    malloc + 8 obj_header_size
    lisp_run_gc
} ;

# <obj> -> <value>
def "obj_i64_get_value" {
    read_mem_i64 + obj_header_size
} ;

# <car obj> <cdr obj> -> <pair obj>
def "alloc_pair" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + 8 + obj_header_size }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap pair_obj_type_id }
    malloc + 16 obj_header_size
    lisp_run_gc
} ;

# <obj> -> <value>
def "obj_pair_car" {
    read_mem_i64 + obj_header_size
    lisp_assert_type "car arg is a pair" pair_obj_type_id dup
} ;

# <obj> -> <value>
def "obj_pair_cdr" {
    read_mem_i64 + 8 + obj_header_size
    assert "cdr: obj is pair" = pair_obj_type_id obj_get_type_id dup
    lisp_assert_type "cdr arg is a pair" pair_obj_type_id dup
} ;

def "obj_pair_invalidate" {
    write_mem_i64 swap -1 + 8 + obj_header_size
    write_mem_i64 swap -1 + obj_header_size dup
} ;
se_check_last_defined_function ;

# <obj> -> <bool>
def "obj_is_pair" {
    if { = 0 dup } {
        false drop
    } {
        = pair_obj_type_id obj_get_type_id
    }
} ;

# <obj> -> <bool>
def "obj_is_list" {
    = 0 while { obj_is_pair dup } { obj_pair_cdr }
} ;

def "obj_list_length" {
    drop
    while { not = 0 dup } {
        dip { + 1 }
        obj_pair_cdr
    }
    dip { 0 }
    assert "obj is list" obj_is_list dup
} ;

# lambda layout [header, env size, arg count, function, env ...]
# <env count> <arg count> <func> -> <lambda>
def "alloc_lambda" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + 16 + obj_header_size } # function
    keep { write_mem_i64 + 8 + obj_header_size } # arg count
    keep { write_mem_i64 + obj_header_size } # env count
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap lambda_obj_type_id }
    malloc + 24 + obj_header_size * 8 dup # allocate 3 fields + header + env
    lisp_run_gc
} ;

def "obj_lambda_get_env_size" { read_mem_i64 + obj_header_size } ;
def "obj_lambda_get_arg_count" { read_mem_i64 + 8 + obj_header_size } ;
def "obj_lambda_get_function" { read_mem_i64 + 16 + obj_header_size } ;
# <lambda> <index> -> <obj>
def "obj_lambda_get_env_value" { read_mem_i64 + 24 + obj_header_size + * 8 swap } ;
# <lambda> <index> <obj> ->
def "obj_lambda_set_env_value" { write_mem_i64 + 24 + obj_header_size + * 8 swap } ;

def "obj_lambda_invalidate" {
    drop
    write_mem_i64 swap -1 + 16 + obj_header_size dup
    write_mem_i64 swap -1 + 8 + obj_header_size dup
    write_mem_i64 swap -1 + obj_header_size dup
} ;
se_check_last_defined_function ;

def "obj_is_lambda" { drop swap lazy_and { = lambda_obj_type_id obj_get_type_id dup } not = 0 dup } ;

def "alloc_bool" {
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap bool_obj_type_id }
    malloc obj_header_size
} ;

constant "obj_bool_true" alloc_bool ;
constant "obj_bool_false" alloc_bool ;

constant "lisp_true_symbol" get_or_create_symbol "#t" ;
constant "lisp_false_symbol" get_or_create_symbol "#f" ;

symbol_bind lisp_true_symbol obj_bool_true ;
symbol_bind lisp_false_symbol obj_bool_false ;

# <obj> -> <cell>
def "alloc_cell" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap cell_obj_type_id }
    malloc + 8 obj_header_size
    lisp_run_gc
} ;

def "obj_cell_get" {
    read_mem_i64 + obj_header_size
} ;

def "obj_cell_set" {
    write_mem_i64 + obj_header_size
} ;

def "obj_cell_invalidate" {
    write_mem_i64 swap -1 + obj_header_size
} ;

# <length> <buffer> -> <obj>
def "alloc_string_from_buffer" {
    keep {
        memcopy -rot
        + 8
        write_mem_i64 2dup
        + obj_header_size
        # <string obj> <length> <buffer>
    }
    keep { obj_set_gc_marked_flag swap false }
    keep { obj_set_type_id swap string_obj_type_id }
    # <string obj ptr> <string>
    malloc + 8 + obj_header_size dup
} ;

# <string> -> <obj>
def "alloc_string" {
    alloc_string_from_buffer bi { byte_vector_get_size } { byte_vector_get_array }
} ;

# <string obj> -> <i64>
def "obj_string_get_size" {
    read_mem_i64 + obj_header_size
} ;

# <string obj> -> <buffer>
def "obj_string_get_buffer" {
    + 8 + obj_header_size
} ;

# <string obj> <string obj> -> <bool>
def "obj_string_eq" {
    dip { 2drop }
    lazy_and {
        = 0
        memcmp 
        dip { bi@ { obj_string_get_buffer } }
        obj_string_get_size dup 
        2dup
    } = bi@ { obj_string_get_size } 2dup
    assert "string-equals args are strings" and bi@ { = string_obj_type_id obj_get_type_id } 2dup
} ;

# <name> <arg count> <instruction>
def "alloc_builtin_func" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + 16 + obj_header_size }
    keep { write_mem_i64 + 8 + obj_header_size }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap builtin_func_obj_type_id }
    malloc + 24 obj_header_size
    lisp_run_gc
} ;

# <obj> -> <value>
def "obj_builtin_get_name" {
    read_mem_i64 + obj_header_size
} ;

# <obj> -> <value>
def "obj_builtin_get_arg_count" {
    read_mem_i64 + 8 + obj_header_size
} ;

# <obj> -> <value>
def "obj_builtin_get_instruction" {
    read_mem_i64 + 16 + obj_header_size
} ;

def "print_obj_quoted"
    when { = obj_bool_true dup } then { print_string "#t" drop } otherwise
    when { = obj_bool_false dup } then { print_string "#f" drop } otherwise
    when { obj_is_list dup } then {
        if { lazy_and { = lisp_quote_symbol obj_pair_car dup } = 2 obj_list_length dup } {
            print_obj_quoted obj_pair_car obj_pair_cdr
            print_string "'"
        } {
            print_string ")"
            drop
            while { not = 0 dup } {
                if { not = 0 dup } { print_string " " } { }
                obj_pair_cdr
                print_obj_quoted obj_pair_car dup
            }
            print_string "("
        }
    } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then { print_buffer bi { symbol_get_buffer } { symbol_get_size } } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then { . obj_i64_get_value } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        print_obj obj_pair_cdr
        print_string " . "
        print_obj obj_pair_car dup
        print_string "("
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then {
        drop
        print_string ")"
        if { td_find_function_name obj_lambda_get_function dup } {
            print_string
        } {
            . obj_lambda_get_function dup print_string "#" drop
        }
        print_string ") "
        drop while { < dip { obj_lambda_get_env_size } 2dup } {
            if { < dip { obj_lambda_get_env_size } 2dup } {
                print_string " "
            } { }
            + 1
            print_obj obj_lambda_get_env_value swap 2dup
            # <index> <lambda>
        } 0
        print_string " (env "
        . obj_lambda_get_arg_count dup
        print_string " arg count: "
        . obj_lambda_get_env_size dup
        print_string " env size: "
        . dup
        print_string "(lambda #"
    } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        print_obj obj_cell_get
        print_string "(cell "
    } otherwise
    when { = string_obj_type_id obj_get_type_id dup } then {
        write_byte_to_stdout double_quote_char
        3drop
        while { > 2dup } {
            dip {
                + 1
                if { is_escape_char dup } {
                    write_byte_to_stdout escape_string_literal_char
                    write_byte_to_stdout backslash_char
                } {
                    write_byte_to_stdout
                }
                read_mem_byte + 2dup
            }
        } # <size> <index> <buffer>
        dip { 0 }
        bi { obj_string_get_size } { obj_string_get_buffer }
        write_byte_to_stdout double_quote_char
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then {
        print_string ">"
        print_string obj_builtin_get_name
        print_string "<builtin function "
    } otherwise
    { assert "OK" false print_newline . obj_get_type_id print_string "print_obj_quoted: unsupported obj type: " }
;

def "print_obj"
    when { obj_is_list dup } then {
        print_obj_quoted print_string "'"
    } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then {
        print_obj_quoted print_string "'"
    } otherwise
    { print_obj_quoted }
;

# <obj> ->
def "destroy_obj"
    when { = bool_obj_type_id obj_get_type_id dup } then { drop } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then { drop } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then {
        free
    } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        free
        obj_pair_invalidate dup
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then {
        free
        obj_lambda_invalidate dup
    } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        free
        obj_cell_invalidate dup
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then { drop } otherwise
    { assert "suppoted obj type" false print_newline . obj_get_type_id }
;
se_check_last_defined_function ;


# <obj> <obj> -> <bool>
def "obj_equal_switch"
    when { = bool_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then {
        = bi@ { obj_i64_get_value }
    } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        dip { 2drop }
        lazy_and { obj_equal bi@ { obj_pair_cdr } 2dup }
        obj_equal bi@ { obj_pair_car } 2dup
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        obj_equal bi@ { obj_cell_get }
    } otherwise
    when { = string_obj_type_id obj_get_type_id dup } then {
        obj_string_eq
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then { = } otherwise
    { false assert "suppoted obj type" false drop print_newline . obj_get_type_id }
 ;

# <obj> <obj> -> <bool>
def "obj_equal" {
    if { = 2dup } {
        true 2drop
    } {
        if { lazy_and { = bi@ { obj_get_type_id } 2dup } and bi@ { not = 0 } 2dup } {
            obj_equal_switch
        } {
            false 2drop
        }
    }
} ;
se_check_last_defined_function ;

constant "current_token_ptr" malloc 8 ;

def "token_scanner_advance" {
    write_mem_i64 current_token_ptr 0
} ;

def "token_scanner_peek" {
    read_mem_i64 current_token_ptr
    if { = read_mem_i64 current_token_ptr 0 } {
        write_mem_i64 current_token_ptr read_next_token
    } { }
} ;

def "token_scanner_print_position" {
    read_mem_i64 current_token_ptr
    if { = read_mem_i64 current_token_ptr 0 } {
        write_mem_i64 current_token_ptr read_next_token
    } { }
} ;

# <char*> <size> -> <bool> <number>
def "parse_i64_non_empty" {
    2drop # <char* end> <char*> <bool> <number>
    if { = 45 read_mem_byte over } {
        # negative
        if { = 2dup } {
            2dip { false drop } # single "-" case
        } {
            while { lazy_and { rot 2dip { dup } } > 2dup } {
                dip {
                    + 1 # <char*> <bool> <number>
                    if { and bi { <= 48 } { > 58 } read_mem_byte dup } {
                        keep {
                            and
                            dip { checked_add * -1 + -48 read_mem_byte }
                            swap
                        } # <char*> <bool> <number>
                        dip { checked_mul 10 drop }
                    } {
                        dip { false drop }
                    }
                }
            }
        }
        dip { + 1 }
    } {
        # positive
        while { lazy_and { rot 2dip { dup } } > 2dup } {
            dip {
                + 1 # <char*> <bool> <number>
                if { and bi { <= 48 } { > 58 } read_mem_byte dup } {
                    keep {
                        and
                        dip { checked_add + -48 read_mem_byte }
                        swap
                    } # <char*> <bool> <number>
                    dip { checked_mul 10 drop }
                } {
                    dip { false drop }
                }
            }
        }
    }
    # <char* end> <char*> <bool> <number>
    swap keep { + }
    2dip { true 0 }
} ;

# <char*> <size> -> <bool> <number>
def "parse_i64" {
    if { < 0 over } {
        parse_i64_non_empty
    } {
        false 0 2drop
    }
} ;

def "parse_i64_string" {
    parse_i64 bi { byte_vector_get_array } { byte_vector_get_size }
} ;

# <byte> -> <bool>
def "is_hex_digit" {
    drop r>
    or
        and > 103 r@ <= 97 r@
        and > 58 r@ <= 48 r@
    >r
} ;

# <byte> -> <number>
def "parse_hex_digit" {
    if { > 58 dup } {
        + -48
    } {
        + -87
    }
} ;

# <char*> <size> -> <bool> <number>
def "parse_hex_i64" {
    if { lazy_and { <= 3 over } >= 18 over } {
        if { lazy_and { = hash_char read_mem_byte dup } = x_char read_mem_byte + 1 dup } {
            2drop
            while { lazy_and { rot 2dip { dup } } > 2dup } {
                dip {
                    + 1
                    keep {
                        if { is_hex_digit read_mem_byte dup } {
                            true
                            + parse_hex_digit read_mem_byte
                            dip { * 16 }
                        } {
                            false drop
                        }
                    }
                    # <current char*> <number>
                    dip { drop }
                }
            }
            # <end char*> <current char*> <bool> <number>
            2dip { true 0 }
            swap
            + 2 # skip prefix
            keep { + }
        } {
            false 0 2drop # wrong prefix
        }
    } {
        false 0 2drop # wrong size
    }
} ;


def "parse_hex_i64_string" {
    parse_hex_i64 bi { byte_vector_get_array } { byte_vector_get_size }
} ;
se_check_last_defined_function ;

constant "lisp_value_stack" array_list_new ;

def "lisp_value_stack_push" {
    array_list_append lisp_value_stack
} ;

def "lisp_value_stack_pop" {
    array_list_pop_last lisp_value_stack
} ;

def "lisp_value_stack_peek_top" {
    array_list_get_last lisp_value_stack
} ;

def "lisp_value_stack_peek" {
    array_list_peek lisp_value_stack
} ;

# <n> ->
def "lisp_value_stack_drop_swap_n_times" {
    array_list_set_size lisp_value_stack - array_list_get_size lisp_value_stack 
    array_list_set lisp_value_stack + -1 - array_list_get_size lisp_value_stack dip { lisp_value_stack_peek_top } dup
} ;
se_check_last_defined_function ;

# <n> ->
def "lisp_value_stack_peek_n_and_push" {
    array_list_append lisp_value_stack
    array_list_get lisp_value_stack + -1 - array_list_get_size lisp_value_stack 
} ;
se_check_last_defined_function ;

# <botton index> <top index> ->
def "lisp_value_stack_remove_slice" {
    array_list_remove_slice lisp_value_stack
    bi@ { + -1 - array_list_get_size lisp_value_stack }
} ;
se_check_last_defined_function ;

def "lisp_value_stack_print" {
    print_string "value stack end\n"
    drop while { <= 0 dup } {
        + -1
        print_newline print_obj print_string " " . dup array_list_get lisp_value_stack dup
        print_string "value stack> #"
    } + -1 array_list_get_size lisp_value_stack
    print_string "value stack:\n"
} ;

constant "lisp_code_literal_list" array_list_new ;

def "lisp_code_literal_list_add" {
    array_list_append lisp_code_literal_list
} ;

# <description str> <type id> <obj>
def "lisp_assert_type" {
    if { lazy_and { = obj_get_type_id 2dup } not = 0 dup } {
        drop 2drop
    } {
        exit 1
        stacktrace_print_return_stack_except_n_slots 2
        print_newline
        print_obj
        print_string " but was "
        print_string obj_type_name
        print_string ": type assertion failed, expected "
        print_string
        rot
        # <type id> <obj> <str>
        swap
    }
    # <obj> <type id> <str>
    swap
    -rot
} ;

constant "lisp_gc_logging_enabled_pointer" malloc 8 ;
write_mem_i64 lisp_gc_logging_enabled_pointer false ;
def "lisp_gc_logging_is_enabled" { read_mem_i64 lisp_gc_logging_enabled_pointer } ;
def "lisp_gc_logging_enable" { write_mem_i64 lisp_gc_logging_enabled_pointer true } ;

constant "lisp_gc_ref_list" array_list_new ;
def "lisp_gc_ref_list_append" {
    array_list_append lisp_gc_ref_list
    if { lisp_gc_logging_is_enabled } {
        print_newline print_obj print_string " " . dup print_string "allocation: #" dup
        print_newline . array_list_get_size lisp_gc_ref_list print_string "allocation: number of alive objs: "
    } { }
} ;

constant "lisp_gc_marker_stack" array_list_new ;

# <obj> ->
def "lisp_gc_marker_stack_push" {
    if { lazy_or { obj_get_gc_marked_flag dup } = 0 dup } {
        drop # do nothing, obj was marked
    } {
        array_list_append lisp_gc_marker_stack
    }
} ;

def "lisp_gc_push_roots_to_stack" {
    lisp_gc_marker_stack_push get_temp_lambda
    drop while { < 0 dup } {
        if { symbol_has_binding dup } {
            lisp_gc_marker_stack_push symbol_get_binding # push bindings
        } { drop }
        array_list_get symbol_list dup
        + -1
    } array_list_get_size symbol_list
    drop while { < 0 dup } {
        lisp_gc_marker_stack_push array_list_get lisp_code_literal_list dup # push code literals
        + -1
    } array_list_get_size lisp_code_literal_list
    drop while { < 0 dup } {
        lisp_gc_marker_stack_push array_list_get lisp_value_stack dup # push value stack
        + -1
    } array_list_get_size lisp_value_stack
} ;

# <obj> ->
def "lisp_gc_mark_push_refs_switch" 
    when { = bool_obj_type_id obj_get_type_id dup } then {
        drop # do nothing
    } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then {
        if { symbol_has_binding dup } {
            lisp_gc_marker_stack_push symbol_get_binding 
        } {
            drop
        }
    } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then {
        drop
    } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        lisp_gc_marker_stack_push obj_pair_cdr
        lisp_gc_marker_stack_push obj_pair_car dup
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then {
        2drop while { < 0 dup } {
            lisp_gc_marker_stack_push obj_lambda_get_env_value swap 2dup
            + -1
        } obj_lambda_get_env_size dup
    } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        lisp_gc_marker_stack_push obj_cell_get
    } otherwise
    when { = string_obj_type_id obj_get_type_id dup } then {
        drop
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then {
        drop
    } otherwise
    { exit 1 print_newline . obj_get_type_id print_string "gc mark: bad object, obj type:" }
;

def "lisp_gc_mark" {
#    if { lisp_gc_logging_is_enabled } {
#        print_newline
#    } { }
    while { not array_list_is_empty lisp_gc_marker_stack } {
        lisp_gc_mark_push_refs_switch
#        if { lisp_gc_logging_is_enabled } {
#            print_string ", "
#            print_obj print_string " " . dup print_string "#" dup
#        } { }
        obj_set_gc_marked_flag swap true dup
        array_list_pop_last lisp_gc_marker_stack
    }
#    if { lisp_gc_logging_is_enabled } {
#        print_string "lisp_gc_mark: "
#    } { }
    lisp_gc_push_roots_to_stack 
} ;

def "lisp_gc_sweep" {
    drop while { < 0 dup } {
        if { not obj_get_gc_marked_flag array_list_get lisp_gc_ref_list dup } {
            if { = + -1 array_list_get_size lisp_gc_ref_list dup } { # if last in ref list
                destroy_obj array_list_pop_last lisp_gc_ref_list
            } {
                array_list_set lisp_gc_ref_list dip { array_list_pop_last lisp_gc_ref_list } dup # replace destroyed obj with last from ref list 
                destroy_obj array_list_get lisp_gc_ref_list dup
            }
        } {
            obj_set_gc_marked_flag swap false array_list_get lisp_gc_ref_list dup
        }
        + -1
    } array_list_get_size lisp_gc_ref_list
    if { lisp_gc_logging_is_enabled } {
        drop while { < 0 dup } {
            if { not obj_get_gc_marked_flag dup } {
                print_newline print_obj print_string " " . dup print_string "gc: will remove #"
            } { drop }
            array_list_get lisp_gc_ref_list dup
            + -1
        } array_list_get_size lisp_gc_ref_list
    } { }
} ;

def "lisp_obj_count" { array_list_get_size lisp_gc_ref_list } ;

constant "lisp_previous_obj_count_ptr" malloc 8 ;
def "lisp_previous_obj_count" { read_mem_i64 lisp_previous_obj_count_ptr } ;
def "lisp_previous_obj_count_set" { write_mem_i64 lisp_previous_obj_count_ptr } ;

lisp_previous_obj_count_set 0 ;

def "lisp_run_gc" {
    if { < * 2 lisp_previous_obj_count lisp_obj_count } {
        lisp_previous_obj_count_set lisp_obj_count
        lisp_gc_sweep
        lisp_gc_mark
    } { }
} ;

constant "open_paren_position_stack" array_list_new ;

def "open_paren_position_stack_push_current_pos" {
    array_list_append open_paren_position_stack token_positon_copy current_token_pos
} ;
se_check_last_defined_function ;

def "open_paren_position_stack_drop" {
    token_positon_destroy array_list_pop_last open_paren_position_stack
} ;

def "open_paren_position_stack_peek_top" {
    array_list_peek open_paren_position_stack 0
} ;

def "open_paren_position_stack_is_empty" {
    array_list_is_empty open_paren_position_stack
} ;

def "read_next_expression_switch"
    when { = token_comma_type token_get_type_id token_scanner_peek } then {
        lisp_value_stack_push drop lisp_value_stack_pop
        alloc_pair lisp_unquote_symbol lisp_value_stack_peek_top
        lisp_value_stack_push drop lisp_value_stack_pop
        alloc_pair lisp_value_stack_peek_top 0
        read_next_expression
        token_scanner_advance
    } otherwise
    when { = token_single_quote_type token_get_type_id token_scanner_peek } then {
        lisp_value_stack_push drop lisp_value_stack_pop
        alloc_pair lisp_quote_symbol lisp_value_stack_peek_top
        lisp_value_stack_push drop lisp_value_stack_pop
        alloc_pair lisp_value_stack_peek_top 0
        read_next_expression
        token_scanner_advance
    } otherwise
    when { 
        lazy_or { = token_open_curly_bracket_type token_get_type_id token_scanner_peek }
        lazy_or { = token_open_bracket_type token_get_type_id token_scanner_peek }
                  = token_open_paren_type token_get_type_id token_scanner_peek
    } then {
        drop
        while { < 0 dup } {
            lisp_value_stack_push
            drop lisp_value_stack_pop
            drop lisp_value_stack_pop
            alloc_pair lisp_value_stack_peek 1 lisp_value_stack_peek 0
            + -1
        }
        lisp_value_stack_push 0
        token_scanner_advance

        open_paren_position_stack_drop
        if { not = token_get_type_id token_scanner_peek } {
            exit 1
            print_newline
            print_string " "
            token_print token_scanner_peek
            print_string " parsing error: unexpected close paren: "
            token_position_print current_token_pos
        } { }
        while { not token_is_close_paren_type token_scanner_peek } {
            dip { + 1 }
            read_next_expression
        }
        swap 0
        token_scanner_advance
#        # [close paren type id]
        token_open_paren_couterpart_type token_get_type_id token_scanner_peek
        open_paren_position_stack_push_current_pos
    } otherwise
    when { token_is_close_paren_type token_scanner_peek } then {
        exit 1
        print_string " parsing error: unexpected close paren\n"
        token_position_print current_token_pos
    } otherwise
    when { = token_EOF_type token_get_type_id token_scanner_peek } then {
        exit 1
        print_newline
        if { not open_paren_position_stack_is_empty } {
            token_position_print open_paren_position_stack_peek_top
            print_string ": unclosed parent at "
        } { }
        print_string "parsing error: unexpected EOF"
    } otherwise
    when { = token_symbol_or_i64_literal_type token_get_type_id token_scanner_peek } then {
        token_scanner_advance
        token_destroy token_scanner_peek
        if { } {
            lisp_value_stack_push alloc_i64
        } {
            if { } {
                lisp_value_stack_push alloc_i64
            } {
                lisp_value_stack_push get_or_create_symbol token_get_value token_scanner_peek drop
            }
            parse_hex_i64_string token_get_value token_scanner_peek
            drop
        }
        parse_i64_string token_get_value token_scanner_peek
    } otherwise
    when { = token_string_literal_type token_get_type_id token_scanner_peek } then {
        token_scanner_advance
        token_destroy token_scanner_peek
        lisp_value_stack_push alloc_string token_get_value token_scanner_peek
    } otherwise
    { assert "supported literal type" false print_newline . token_get_type_id token_scanner_peek }
;

def "read_next_expression" {
    read_next_expression_switch
} ;

# <obj> <obj> -> <obj>
def "obj_i64_add" {
    alloc_i64 + bi@ { obj_i64_get_value }
    bi@ { lisp_assert_type "'add' args are i64" i64_obj_type_id } 2dup
} ;

# <name> <func>
def "register_lisp_instruction" {
    def string_concat swap "_f"
    constant 2dup
} ;

register_lisp_instruction "obj_i64_equal_instruction" {
    lisp_value_stack_push
    if { } { obj_bool_true } { obj_bool_false }
    = bi@ { obj_i64_get_value }
    bi@ { lisp_assert_type "'add' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "obj_i64_add_instruction" {
    lisp_value_stack_push
    alloc_i64 + bi@ { obj_i64_get_value }
    bi@ { lisp_assert_type "'add' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "obj_i64_sub_instruction" {
    lisp_value_stack_push
    alloc_i64 - bi@ { obj_i64_get_value }
    bi@ { lisp_assert_type "'sub' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "obj_i64_mul_instruction" {
    lisp_value_stack_push
    alloc_i64 * bi@ { obj_i64_get_value }
    bi@ { lisp_assert_type "'mul' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "obj_i64_div_instruction" {
    lisp_value_stack_push
    alloc_i64 / bi@ { obj_i64_get_value }
    bi@ { lisp_assert_type "'div' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "obj_i64_gt_instruction" {
    lisp_value_stack_push
    if { > bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { lisp_assert_type "'>' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "obj_i64_lt_instruction" {
    lisp_value_stack_push
    if { < bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { lisp_assert_type "'<' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "obj_i64_gte_instruction" {
    lisp_value_stack_push
    if { >= bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { lisp_assert_type "'>=' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "obj_i64_lte_instruction" {
    lisp_value_stack_push
    if { <= bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { lisp_assert_type "'<=' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "literal_instruction" {
    lisp_value_stack_push lisp_program_stack_pop
} ;

register_lisp_instruction "drop_instruction" {
    drop lisp_value_stack_pop
} ;

register_lisp_instruction "define_instruction" {
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    symbol_bind
    # <symbol> <value>
    lisp_value_stack_peek 0 # symbol
    lisp_value_stack_peek 1 # value
    if { symbol_has_binding lisp_value_stack_peek 0 } {
        exit 1
        print_newline
        print_obj lisp_value_stack_peek 0
        print_string "symbol is already defined: "
    } { }
} ;

constant "temp_lambda_ptr" malloc 8 ;

def "set_temp_lambda" {
    write_mem_i64 temp_lambda_ptr
} ;

def "get_temp_lambda" {
    read_mem_i64 temp_lambda_ptr
} ;
set_temp_lambda 0 ;


register_lisp_instruction "car_instruction" {
    if { obj_is_pair lisp_value_stack_peek_top } {
        lisp_value_stack_push obj_pair_car lisp_value_stack_pop
    } {
        exit 1
        stacktrace_print_return_stack_except_n_slots 1
        print_newline print_obj lisp_value_stack_peek_top
        print_string "error: car of obj: "
    }
} ;

register_lisp_instruction "cdr_instruction" {
    lisp_value_stack_push obj_pair_cdr lisp_value_stack_pop
} ;

register_lisp_instruction "cons_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_pair lisp_value_stack_peek 1 lisp_value_stack_peek 0
} ;

register_lisp_instruction "read_syntax_instruction" {
    read_next_expression
} ;

register_lisp_instruction "print_instruction" {
    lisp_value_stack_push 0
    print_obj lisp_value_stack_pop
} ;

register_lisp_instruction "print_string_instruction" {
    lisp_value_stack_push 0
    print_buffer bi { obj_string_get_buffer } { obj_string_get_size }
    lisp_assert_type "print-string arg is string" string_obj_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "make_cell_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    alloc_cell lisp_value_stack_peek_top
} ;

register_lisp_instruction "cell_get_instruction" {
    lisp_value_stack_push obj_cell_get lisp_value_stack_pop
} ;

register_lisp_instruction "cell_set_instruction" {
    lisp_value_stack_push 0
    obj_cell_set lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "exit_instruction" {
    lisp_value_stack_push 0
    exit obj_i64_get_value lisp_value_stack_pop
    assert "exit arg is i64" = i64_obj_type_id obj_get_type_id lisp_value_stack_peek_top
} ;

register_lisp_instruction "equal_instruction" {
    if { obj_equal lisp_value_stack_pop lisp_value_stack_pop } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
} ;

register_lisp_instruction "not_instruction" {
    lisp_value_stack_push
    if { = obj_bool_false } {
        obj_bool_true
    } {
        obj_bool_false
    }
    if { not lazy_or { = obj_bool_true dup } = obj_bool_false dup } {
        exit 1
        print_newline
        print_obj dup
        print_string "'not' on non-boolean obj: "
    } { }
    lisp_value_stack_pop
} ;

register_lisp_instruction "list_q_instruction" {
    if { obj_is_list lisp_value_stack_pop } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
} ;

# <obj> -> <bool>
def "lisp_obj_is_i64" {
    drop swap
    lazy_and { = i64_obj_type_id obj_get_type_id dup } not = 0 dup
} ;
se_check_last_defined_function ;

def "syscall_pop_i64" {
    obj_i64_get_value 
    lisp_assert_type "syscall arg is i64" i64_obj_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "syscall_instruction" {
    lisp_value_stack_push alloc_i64 syscall
    syscall_pop_i64
    syscall_pop_i64
    syscall_pop_i64
    syscall_pop_i64
    syscall_pop_i64
    syscall_pop_i64
    syscall_pop_i64
} ;

register_lisp_instruction "native_call_instruction" {
    lisp_value_stack_push
    alloc_i64 native_call obj_i64_get_value
    lisp_assert_type "native-call arg is i64" i64_obj_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "read_mem_i64_instruction" {
    lisp_value_stack_push
    alloc_i64 read_mem_i64 obj_i64_get_value
    lisp_assert_type "read-mem-i64" i64_obj_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "write_mem_i64_instruction" {
    lisp_value_stack_push 0
    write_mem_i64 bi@ { obj_i64_get_value }
    bi@ { lisp_assert_type "write-mem-i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "read_mem_byte_instruction" {
    lisp_value_stack_push
    alloc_i64 read_mem_byte obj_i64_get_value
    lisp_assert_type "read-mem-byte" i64_obj_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "write_mem_byte_instruction" {
    lisp_value_stack_push 0
    write_mem_byte bi@ { obj_i64_get_value }
    assert "write-mem-byte args are i64" and bi@ { = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "bitwise_ior_instruction" {
    lisp_value_stack_push
    alloc_i64 bit_or bi@ { obj_i64_get_value }
    assert "bitwise-ior args are i64" and bi@ { = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "string_length_instruction" {
    lisp_value_stack_push
    alloc_i64 obj_string_get_size
    assert "string-length arg is string" = string_obj_type_id obj_get_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "string_get_byte_instruction" {
    lisp_value_stack_push
    alloc_i64 read_mem_byte + bi* { obj_string_get_buffer } { obj_i64_get_value } 2dup
    2drop
    assert "string-get-byte: in range" lazy_and { > 2dup } <= 0 over 
    bi* { obj_string_get_size } { obj_i64_get_value } 2dup
    # <string obj> <i64 obj>
    bi*
        { lisp_assert_type "string-get-byte first arg is string" string_obj_type_id }
        { lisp_assert_type "string-get-byte second arg is i64" i64_obj_type_id }
    2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;



constant "lisp_define_symbol" get_or_create_symbol "define" ;
constant "lisp_lambda_symbol" get_or_create_symbol "lambda" ;
constant "lisp_let_symbol" get_or_create_symbol "let" ;
constant "lisp_if_symbol" get_or_create_symbol "if" ;
constant "lisp_begin_symbol" get_or_create_symbol "begin" ;
constant "lisp_quote_symbol" get_or_create_symbol "quote" ;
constant "lisp_unquote_symbol" get_or_create_symbol "unquote" ;

def "obj_is_symbol" { drop swap lazy_and { = symbol_obj_type_id obj_get_type_id dup } not = 0 dup } ;
se_check_last_defined_function ;

def "obj_is_builtin" { drop swap lazy_and { = builtin_func_obj_type_id obj_get_type_id dup } not = 0 dup } ;
se_check_last_defined_function ;

constant "code_buffer_stack" array_list_new ;
constant "code_buffer_enabled_flag_stack" array_list_new ;
array_list_append code_buffer_enabled_flag_stack true ;

def "lisp_compile_stop_producing_code" { array_list_set_last code_buffer_enabled_flag_stack false } ;

# -> <bool>
def "code_buffer_is_enabled" { array_list_get_last code_buffer_enabled_flag_stack } ;

def "code_buffer_stack_peek" { array_list_get_last code_buffer_stack } ;
se_check_last_defined_function ;
def "code_buffer_stack_push_new" {
    array_list_append code_buffer_stack code_buffer_new
    array_list_append code_buffer_enabled_flag_stack true
} ;
se_check_last_defined_function ;
def "code_buffer_stack_pop" {
    code_buffer_make_function_and_destroy array_list_pop_last code_buffer_stack
    drop array_list_pop_last code_buffer_enabled_flag_stack
} ;
se_check_last_defined_function ;

# <value> ->
def "lisp_compile_prepend_literal" { 
    if { code_buffer_is_enabled } {
        code_buffer_prepend_literal code_buffer_stack_peek
    } {
        drop
    }
} ;
se_check_last_defined_function ;

# <func> ->
def "lisp_compile_prepend_code" { 
    if { code_buffer_is_enabled } {
        code_buffer_prepend_code code_buffer_stack_peek
    } {
        drop
    }
} ;
se_check_last_defined_function ;

# <func> ->
def "lisp_compile_prepend_call" { 
    if { code_buffer_is_enabled } {
        code_buffer_prepend_call code_buffer_stack_peek
    } {
        drop
    }
} ;
se_check_last_defined_function ;

constant "stack_bindings_stack" array_list_new ;

def "stack_bindings" { array_list_get_last stack_bindings_stack } ;

def "stack_bindings_stack_push_new" {
    array_list_append stack_bindings_stack array_list_new
} ;
se_check_last_defined_function ;

stack_bindings_stack_push_new ;

def "stack_bindings_stack_drop" {
    array_list_destroy array_list_pop_last stack_bindings_stack
} ;
se_check_last_defined_function ;

def "stack_bindings_push_unnamed" {
    array_list_append stack_bindings 0
} ;
se_check_last_defined_function ;

# <symbol> ->
def "stack_bindings_bind_top" {
    array_list_set stack_bindings + -1 array_list_get_size stack_bindings 
} ;
se_check_last_defined_function ;

# <num items to drop> ->
def "stack_bindings_drop_n" {
    assert "size is >= 0" <= 0 array_list_get_size stack_bindings
    array_list_set_size stack_bindings - array_list_get_size stack_bindings
} ;
se_check_last_defined_function ;

# <num items to drop> ->
def "stack_bindings_drop_swap_n_times" {
    array_list_set_size stack_bindings - array_list_get_size stack_bindings 
    array_list_set stack_bindings + -1 - array_list_get_size stack_bindings dip { array_list_get_last stack_bindings } dup
} ;
se_check_last_defined_function ;

# <symbol> -> <found bool> <stack index>
def "stack_bindings_find" {
    if { = -1 dup } {
        false
    } {
        true + -1 - array_list_get_size stack_bindings 
    }
    drop swap
    while { lazy_and { not = array_list_get stack_bindings 2dup } <= 0 dup } { + -1 }
    # <index> <symbol>
    + -1 array_list_get_size stack_bindings
} ;
se_check_last_defined_function ;

constant "captured_values_list_stack" array_list_new ;
def "captured_values_list" { array_list_get_last captured_values_list_stack } ;
se_check_last_defined_function ;
def "captured_values_list_stack_push_new" { array_list_append captured_values_list_stack array_list_new } ;
se_check_last_defined_function ;
def "captured_values_list_stack_pop" { array_list_pop_last captured_values_list_stack } ;
se_check_last_defined_function ;

# <symbol> -> <found bool> <env index>
def "captured_values_find" {
    if { = -1 dup } {
        false
    } {
        true 
    }
    drop swap
    while { lazy_and { not = array_list_get captured_values_list 2dup } <= 0 dup } { + -1 }
    # <index> <symbol>
    + -1 array_list_get_size captured_values_list
} ;
se_check_last_defined_function ;

# <symbol> -> <env index>
def "captured_values_register_if_absent_and_get_index" {
    if { } {
        drop swap
    } {
        + -1 array_list_get_size captured_values_list
        array_list_append captured_values_list
        drop
        # <index> <symbol>
    }
    captured_values_find dup
} ;
se_check_last_defined_function ;

captured_values_list_stack_push_new ;

constant "lexical_scope_list" array_list_new ;
def "lexical_scope_push" { array_list_append lexical_scope_list } ;
# <num items to drop> ->
def "lexical_scope_drop_n" {
    array_list_set_size lexical_scope_list - array_list_get_size lexical_scope_list
} ;
# <symbol> -> <bool>
def "lexical_scope_contains" {
    not = -1
    drop swap
    while { lazy_and { not = array_list_get lexical_scope_list 2dup } <= 0 dup } { + -1 }
    # <index> <symbol>
    + -1 array_list_get_size lexical_scope_list
} ;
se_check_last_defined_function ;

constant "tco_postpone_counts_stack" array_list_new ;
def "tco_postpone_counts_stack_push_zero" { array_list_append tco_postpone_counts_stack 0 } ;
def "tco_postpone_counts_stack_drop" { assert "tco postpone count is zero" = 0 array_list_pop_last tco_postpone_counts_stack } ;
def "tco_postpone_count_increment" { array_list_append tco_postpone_counts_stack + 1 array_list_pop_last tco_postpone_counts_stack } ;
def "tco_postpone_count_decrement" {
    array_list_append tco_postpone_counts_stack
    + -1
    assert "tco postpone count is greater than zero" < 0 dup
    array_list_pop_last tco_postpone_counts_stack
} ;
def "tco_postpone_count_is_zero" { = 0 array_list_peek tco_postpone_counts_stack 0 } ;
constant "tco_enabled_ptr" malloc 8 ;
write_mem_i64 tco_enabled_ptr true ;
def "tco_is_enabled" { read_mem_i64 tco_enabled_ptr } ;
def "tco_disable" { write_mem_i64 tco_enabled_ptr false } ;
def "tco_is_tail_call" { lazy_and { tco_postpone_count_is_zero } tco_is_enabled } ;

tco_postpone_counts_stack_push_zero ;

# <lambda> <arg count> -> <lambda> <arg count>
def "lisp_compilation_template_lambda_arg_check" {
    if { = obj_lambda_get_arg_count 2dup } { } {
        exit 1
        stacktrace_print_return_stack_except_n_slots 1
        print_newline
        . over
        print_string " args, but was "
        . obj_lambda_get_arg_count dup
        print_string "' takes "
        print_obj dup
        print_string "error: wrong arg count: lambda function '"
    }
} ;
se_check_last_defined_function ;

# <builtin> <arg count> -> <builtin> <arg count>
def "lisp_compilation_template_builtin_arg_check" {
    if { = obj_builtin_get_arg_count 2dup } { } {
        exit 1
        print_newline
        . over
        print_string " args, but was "
        . obj_builtin_get_arg_count dup
        print_string "' takes "
        print_string obj_builtin_get_name dup
        print_string "error: wrong arg count: builtin function '"
    }
} ;
se_check_last_defined_function ;

# <number of values to retain> ->
def "lisp_compile_prepend_remove_temp_values_from_the_stack" {
    # emit 'remove slice' only if there are temp values on the stack
    if { not = array_list_get_size stack_bindings dup } {
        lisp_compile_prepend_code {
            lisp_value_stack_remove_slice # <bottom index> <top index>
        }
        lisp_compile_prepend_literal + -1 array_list_get_size stack_bindings # bottom index
        lisp_compile_prepend_literal + -1
    } { drop }
} ;

def "lisp_compile_lambda" {
    drop
    if { tco_is_tail_call } {
        lisp_compile_stop_producing_code
        lisp_compile_prepend_remove_temp_values_from_the_stack 1
    } { }
    stack_bindings_push_unnamed
    lisp_compile_prepend_code { lisp_value_stack_push }
    array_list_destroy
    array_list_foreach_item_and_index
    {
        lisp_compile_prepend_code {
            # <lambda>
            obj_lambda_set_env_value
            # <lambda> <index> <value> <lambda>
            rot
            # <index> <value> <lambda> <lambda>
        }
        lisp_compile_prepend_literal  # emit index
        lisp_compile_prepend_code {
            # <value> <lambda> <lambda>
            lisp_value_stack_pop
            dup
        }
        stack_bindings_drop_n 1
        tco_postpone_count_decrement
        lisp_compile_symbol
        tco_postpone_count_increment
        # <symbol> <index>
    } dup
    captured_values_list_stack_pop
    lisp_compile_prepend_code {
        alloc_lambda
        # <env count> <arg count> <func>
    }
    lisp_compile_prepend_literal array_list_get_size captured_values_list # env size
    lisp_compile_prepend_literal obj_list_length obj_pair_car dup # arg count
    lisp_compile_prepend_literal
    #print_newline
    #pf_print_function dup
    #print_string "lambda code:\n"
    code_buffer_stack_pop # func

    lexical_scope_drop_n obj_list_length obj_pair_car dup # drop args from lexical scope
    stack_bindings_stack_drop

    tco_postpone_counts_stack_drop
    lisp_compile_prepend_code {
        lisp_value_stack_drop_swap_n_times
    }
    lisp_compile_prepend_literal + 1 obj_list_length obj_pair_car dup # drop args and lambda
    #assert "tco was triggered" not code_buffer_is_enabled
    lisp_compile_expression obj_pair_car obj_pair_cdr dup # compile lambda body
    tco_postpone_counts_stack_push_zero
    code_buffer_stack_push_new
    drop while { not = 0 dup } {
        obj_pair_cdr
        lexical_scope_push
        stack_bindings_bind_top dup
        stack_bindings_push_unnamed
        lisp_assert_type "arg list contains symbols" symbol_obj_type_id dup
        # <symbol> <rest> ..
        obj_pair_car dup
    } obj_pair_car dup
    stack_bindings_push_unnamed # lambda obj

    stack_bindings_stack_push_new
    captured_values_list_stack_push_new

    assert "lambda has arg list" obj_is_list obj_pair_car dup
    assert "lambda has 2 args" = 2 obj_list_length dup
    obj_pair_cdr
} ;

def "lisp_compile_if" {
    drop
    if { tco_is_tail_call } {
        lisp_compile_stop_producing_code
    } { }
    lisp_compile_prepend_code { if } 

    lisp_compile_prepend_literal code_buffer_stack_pop
    # do not drop bindings stack because 'if' expression puts a value on the stack
    lisp_compile_prepend_code {
        = obj_bool_true
        lisp_assert_type "if cond" bool_obj_type_id dup
        lisp_value_stack_pop
    }
    tco_postpone_count_decrement
    lisp_compile_expression obj_pair_car dup # compile condition
    tco_postpone_count_increment
    code_buffer_stack_push_new

    lisp_compile_prepend_literal code_buffer_stack_pop
    stack_bindings_drop_n 1
    lisp_compile_expression obj_pair_car obj_pair_cdr dup # compile then
    code_buffer_stack_push_new

    lisp_compile_prepend_literal code_buffer_stack_pop
    stack_bindings_drop_n 1
    lisp_compile_expression obj_pair_car obj_pair_cdr obj_pair_cdr dup # compile else
    code_buffer_stack_push_new

    assert "if has 3 args" = 3 obj_list_length dup
    obj_pair_cdr
} ;

def "lisp_compile_let" {
    drop
    bi { stack_bindings_drop_swap_n_times } { lexical_scope_drop_n } obj_list_length obj_pair_car dup
    lisp_compile_prepend_code {
        lisp_value_stack_drop_swap_n_times
    }
    lisp_compile_prepend_literal obj_list_length obj_pair_car dup
    lisp_compile_expression obj_pair_car obj_pair_cdr dup # compile 'let' body
    tco_postpone_count_decrement
    keep {
        drop while { not = 0 dup } {
            obj_pair_cdr
            lexical_scope_push obj_pair_car obj_pair_car dup # update lexical scope
            stack_bindings_bind_top obj_pair_car obj_pair_car dup # bind stack slot to symbol
            lisp_compile_expression obj_pair_car obj_pair_cdr obj_pair_car dup # compile binding body
        }
        obj_pair_car
    }
    tco_postpone_count_increment
    assert "let has bindings list" obj_is_list obj_pair_car dup
    assert "let has 2 args" = 2 obj_list_length dup
    obj_pair_cdr
} ;

def "lisp_compile_quote" {
    drop
    if { tco_is_tail_call } {
        lisp_compile_stop_producing_code
        lisp_compile_prepend_remove_temp_values_from_the_stack 1
    } { }
    stack_bindings_push_unnamed
    lisp_compile_prepend_code {
        lisp_value_stack_push
    }
    lisp_compile_prepend_literal obj_pair_car dup
    lisp_code_literal_list_add obj_pair_car dup
    assert "quote has one argument" = 1 obj_list_length dup
    obj_pair_cdr
} ;

def "lisp_compile_globally_defined_bulitin_func_call" {
    stack_bindings_push_unnamed
    stack_bindings_drop_n + -1 obj_list_length
    if { tco_is_tail_call } {
        lisp_compile_stop_producing_code
    } { }
    lisp_compile_prepend_call obj_builtin_get_instruction symbol_get_binding obj_pair_car dup
    if { tco_is_tail_call } {
        lisp_compile_prepend_remove_temp_values_from_the_stack + -1 obj_list_length dup # pass arg count
    } { }
    tco_postpone_count_decrement
    keep {
        drop while { not = 0 dup } {
            obj_pair_cdr
            lisp_compile_expression obj_pair_car dup
        } obj_pair_cdr
    }
    tco_postpone_count_increment
    if { = bi
        { + 1 obj_builtin_get_arg_count symbol_get_binding obj_pair_car }
        { obj_list_length } dup } { } {
        exit 1
        print_newline
        . + -1 obj_list_length dup
        print_string " args, but was "
        . obj_builtin_get_arg_count symbol_get_binding obj_pair_car dup
        print_string "' takes "
        print_string obj_builtin_get_name symbol_get_binding obj_pair_car dup
        print_string "error: wrong arg count: builtin function '"
    }
} ;

# <lambda or builtin> <arg count> ->
def "lisp_generic_call" TCO {
    if { obj_is_builtin dup } {
        lisp_value_stack_drop_swap_n_times 1 # remove builtin from the stack
        call obj_builtin_get_instruction
        drop swap
        lisp_compilation_template_builtin_arg_check
    } {
        jmp obj_lambda_get_function
        drop swap
        lisp_compilation_template_lambda_arg_check
        lisp_assert_type "object is callable" lambda_obj_type_id dup
    }
    # <lambda or builtin> <arg count>
} ;

def "lisp_compile_generic_call" {
    drop
    stack_bindings_drop_n + -1 obj_list_length dup
    if { tco_is_tail_call } {
        lisp_compile_stop_producing_code
        lisp_compile_prepend_code {
            lisp_generic_call
        }
        lisp_compile_prepend_code {
            # <lambda or bultin> <arg count>
            lisp_value_stack_peek
            dup 
            # <lambda or builtin index (arg count)>
        }
        lisp_compile_prepend_literal + -1 obj_list_length dup # lambda or builtin index (arg count) # top index
        lisp_compile_prepend_remove_temp_values_from_the_stack obj_list_length dup # retain arg count + 1 (lambda) values
    } {
        lisp_compile_prepend_code {
            lisp_generic_call
            lisp_value_stack_peek
            dup
            # <lambda or builtin index (arg count)>
        }
        lisp_compile_prepend_literal + -1 obj_list_length dup
    }
    tco_postpone_count_decrement
    drop while { not = 0 dup } {
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
    } dup
    tco_postpone_count_increment
} ;

def "lisp_compile_begin" {
    drop
    stack_bindings_drop_n + -1 obj_list_length dup
    lisp_compile_prepend_code {
        lisp_value_stack_drop_swap_n_times
    }
    lisp_compile_prepend_literal + -1 obj_list_length dup
    drop while { not = 0 dup } {
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        if { = 0 obj_pair_cdr dup } {
            tco_postpone_count_decrement # enable tco for the last expression
        } { }
    } dup
    tco_postpone_count_increment
    assert "begin has args" not = 0 dup
    obj_pair_cdr
} ;

def "lisp_compile_define" {
    if { tco_is_tail_call } {
        lisp_compile_stop_producing_code
        lisp_compile_prepend_remove_temp_values_from_the_stack 1
    } { }
    drop
    lisp_compile_prepend_code {
        lisp_value_stack_push # put symbol on the stack
        symbol_bind swap
        # <value> <symbol> <symbol>
        lisp_value_stack_pop
        dup
        # <symbol>
    }
    lisp_compile_prepend_literal obj_pair_car dup

    tco_postpone_count_decrement
    lisp_compile_expression obj_pair_car obj_pair_cdr dup
    tco_postpone_count_increment
    lisp_assert_type "define: first arg is a symbol" symbol_obj_type_id obj_pair_car dup
    assert "define has two arguments" = 2 obj_list_length dup
    obj_pair_cdr
} ;

def "lisp_compile_list"
    when { = lisp_quote_symbol obj_pair_car dup } then { lisp_compile_quote } otherwise
    when { = lisp_lambda_symbol obj_pair_car dup } then { lisp_compile_lambda } otherwise
    when { = lisp_let_symbol obj_pair_car dup } then { lisp_compile_let } otherwise
    when { = lisp_if_symbol obj_pair_car dup } then { lisp_compile_if } otherwise
    when { = lisp_begin_symbol obj_pair_car dup } then { lisp_compile_begin } otherwise
    when { = lisp_define_symbol obj_pair_car dup } then { lisp_compile_define } otherwise

    when { lazy_and { obj_is_builtin symbol_get_binding obj_pair_car dup }
           lazy_and { symbol_has_binding obj_pair_car dup }
           lazy_and { not lexical_scope_contains obj_pair_car dup }
           obj_is_symbol obj_pair_car dup } then {
        lisp_compile_globally_defined_bulitin_func_call
    } otherwise
    { lisp_compile_generic_call }
;

def "lisp_compile_symbol" {
    if { tco_is_tail_call } {
        lisp_compile_stop_producing_code
        lisp_compile_prepend_remove_temp_values_from_the_stack 1
    } { }
    stack_bindings_push_unnamed
    if { } {
        lisp_compile_prepend_code {
            lisp_value_stack_peek_n_and_push
            #lisp_value_stack_print
        }
        lisp_compile_prepend_literal 
        drop swap
    } {
        if { lexical_scope_contains dup } {
            lisp_compile_prepend_code {
                lisp_value_stack_push obj_lambda_get_env_value
                lisp_assert_type "lambda env access" lambda_obj_type_id dup
                lisp_value_stack_peek
            }
            lisp_compile_prepend_literal + -1 array_list_get_size stack_bindings # lambda's stack address
            lisp_compile_prepend_literal captured_values_register_if_absent_and_get_index # env binding index
            # <symbol>
        } {
            lisp_compile_prepend_code {
                lisp_value_stack_push symbol_get_binding
                if { symbol_has_binding dup } { } {
                    exit 1
                    stacktrace_print_return_stack_except_n_slots 1
                    print_string " is undefined\n"
                    print_obj dup
                    print_string "symbol "
                }
            }
            lisp_compile_prepend_literal
        }
        # <symbol>
        drop
    }
    stack_bindings_find dup
} ;

def "lisp_compile_expression_switch" 
    when { obj_is_list dup } then {
        lisp_compile_list
    } otherwise
    when { obj_is_symbol dup } then {
        lisp_compile_symbol
    } otherwise
    {
        if { tco_is_tail_call } {
            lisp_compile_stop_producing_code
            lisp_compile_prepend_remove_temp_values_from_the_stack 1
        } { }
        stack_bindings_push_unnamed
        lisp_compile_prepend_code {
            lisp_value_stack_push
        }
        lisp_compile_prepend_literal
        lisp_code_literal_list_add dup
    }
;

def "lisp_compile_expression" {
    lisp_compile_expression_switch
    assert "obj type id is OK" and bi { <= 0 } { >= 7 } obj_get_type_id dup
    assert "syntax is not null" not = 0 dup
} ;

constant "lisp_eval_debug_enabled_ptr" malloc 8 ;
write_mem_i64 lisp_eval_debug_enabled_ptr false ;
def "lisp_eval_debug_enable" { write_mem_i64 lisp_eval_debug_enabled_ptr true } ;
def "lisp_eval_debug_enabled" { read_mem_i64 lisp_eval_debug_enabled_ptr } ;

# ->
constant "lisp_eval" {
    jmp
    if { lisp_eval_debug_enabled } {
        pf_print_function dup
        print_string "eval function:\n"
    } { }
    code_buffer_stack_pop
    stack_bindings_drop_n 1
    assert "tco postpone count is zero" tco_postpone_count_is_zero
    assert "tco postpone counts stack size is 1" = 1 array_list_get_size tco_postpone_counts_stack
    assert "lexical scope is empty" array_list_is_empty lexical_scope_list
    assert "captured_values_list is empty" array_list_is_empty captured_values_list
    assert "captured_values_list_stack contains a single element" = 1 array_list_get_size captured_values_list_stack
    assert "single value on compile stack" = 1 array_list_get_size stack_bindings
    lisp_compile_expression
#    print_newline
#    print_obj dup
#    print_string "eval expression:\n"
    lisp_value_stack_pop
    code_buffer_stack_push_new
} ;

# <name> <arg count> <func> ->
def "lisp_register_builtin_function" {
    symbol_bind get_or_create_symbol keep { alloc_builtin_func }
    def string_concat "lisp builtin: "
    # <name> <func>
    drop swap 3dup
} ;

lisp_register_builtin_function "=" 2 obj_i64_equal_instruction ;
lisp_register_builtin_function "+" 2 obj_i64_add_instruction ;
lisp_register_builtin_function "-" 2 obj_i64_sub_instruction ;
lisp_register_builtin_function "*" 2 obj_i64_mul_instruction ;
lisp_register_builtin_function "/" 2 obj_i64_div_instruction ;
lisp_register_builtin_function "min" 2 {
    lisp_value_stack_push alloc_i64
    if { < 2dup } {
        drop swap
    } {
        drop
    }
    obj_i64_get_value swap
    obj_i64_get_value
    bi@ { lisp_assert_type "'min' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;
lisp_register_builtin_function "max" 2 {
    lisp_value_stack_push alloc_i64
    if { < 2dup } {
        drop
    } {
        drop swap
    }
    obj_i64_get_value swap
    obj_i64_get_value
    bi@ { lisp_assert_type "'max' args are i64" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

lisp_register_builtin_function ">" 2 obj_i64_gt_instruction ;
lisp_register_builtin_function ">=" 2 obj_i64_gte_instruction ;
lisp_register_builtin_function "<" 2 obj_i64_lt_instruction ;
lisp_register_builtin_function "<=" 2 obj_i64_lte_instruction ;

lisp_register_builtin_function "equal?" 2 equal_instruction ;
lisp_register_builtin_function "print" 1 print_instruction ;
lisp_register_builtin_function "print-string" 1 print_string_instruction ;

lisp_register_builtin_function "car" 1 car_instruction ;
lisp_register_builtin_function "cdr" 1 cdr_instruction ;
lisp_register_builtin_function "cons" 2 cons_instruction ;
lisp_register_builtin_function "nth" 2 {
    if { lazy_and { not = 0 dup } = 0 } { # n should be 0 and list should not be '()
        2drop
        lisp_value_stack_push obj_pair_car
    } {
        exit 1
        stacktrace_print_return_stack_except_n_slots 1
        print_newline
        .
        print_string ", index is: "
        . obj_list_length
        print_string "nth: out of range: list length is "
        drop
    }
    # <n> <list> <original list> <original n>
    swap
    while { lazy_and { < 0 over } not = 0 dup } {
        swap + -1 swap
        obj_pair_cdr
    }
    2dup # <list obj> <n>
    swap
    obj_i64_get_value
    assert "nth: first arg is i64" lisp_obj_is_i64 dup lisp_value_stack_pop
    assert "nth: second arg is list" obj_is_list dup lisp_value_stack_pop
} ;
lisp_register_builtin_function "first" 1 car_instruction ;
lisp_register_builtin_function "second" 1 {
    lisp_value_stack_push
    obj_pair_car obj_pair_cdr
    assert "second: list length >= 2" <= 2 obj_list_length dup
    assert "second: arg is list" obj_is_list dup
    if { not obj_is_list dup } {
        exit 1
        stacktrace_print_return_stack_except_n_slots 1
        print_newline
        print_obj dup
        print_string "second: list expected, but was: "
    } { }
    lisp_value_stack_pop
} ;

lisp_register_builtin_function "cell" 1 make_cell_instruction ;
lisp_register_builtin_function "cell-get" 1 cell_get_instruction ;
lisp_register_builtin_function "cell-set" 2 cell_set_instruction ;

lisp_register_builtin_function "read-syntax" 0 read_syntax_instruction ;


lisp_register_builtin_function "print-stack-trace" 0 {
    lisp_value_stack_push 0
    stacktrace_print_return_stack_except_n_slots 0
} ;

lisp_register_builtin_function "eval" 1 lisp_eval ;

lisp_register_builtin_function "id" 1 { } ;
lisp_register_builtin_function "not" 1 not_instruction ;

lisp_register_builtin_function "empty?" 1 {
    lisp_value_stack_push
    if { = 0 } {
        obj_bool_true
    } {
        obj_bool_false
    }
    lisp_value_stack_pop
} ;

lisp_register_builtin_function "symbol?" 1 {
    if { drop swap lazy_and { = symbol_obj_type_id obj_get_type_id dup } not = 0 dup } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
    lisp_value_stack_pop
} ;
lisp_register_builtin_function "number?" 1 {
    if { drop swap lazy_and { = i64_obj_type_id obj_get_type_id dup } not = 0 dup } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
    lisp_value_stack_pop
} ;
lisp_register_builtin_function "string?" 1 {
    if { drop swap lazy_and { = string_obj_type_id obj_get_type_id dup } not = 0 dup } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
    lisp_value_stack_pop
} ;
lisp_register_builtin_function "procedure?" 1 {
    if {
        drop swap lazy_and {
            lazy_or { = lambda_obj_type_id obj_get_type_id dup }
            = builtin_func_obj_type_id obj_get_type_id dup
        }
        not = 0 dup
    } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
    lisp_value_stack_pop
} ;
lisp_register_builtin_function "list?" 1 list_q_instruction ;
lisp_register_builtin_function "pair?" 1 {
    if { obj_is_pair lisp_value_stack_pop } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
} ;
lisp_register_builtin_function "length" 1 {
    lisp_value_stack_push
    alloc_i64 obj_list_length
    lisp_value_stack_pop
} ;

lisp_register_builtin_function "arity" 1 {
    lisp_value_stack_push
    alloc_i64
    if { obj_is_builtin dup } {
        obj_builtin_get_arg_count
    } {
        obj_lambda_get_arg_count
        lisp_assert_type "object is callable" lambda_obj_type_id dup
    }
    lisp_value_stack_pop
} ;

constant "lisp_the_s2_dictionaty_ptr_symbol" get_or_create_symbol "the-s2-dictionary-ptr" ;
symbol_bind lisp_the_s2_dictionaty_ptr_symbol alloc_i64 the_dictionary ;
constant "lisp_s2_return_stack_ptr_symbol" get_or_create_symbol "s2-return-stack-ptr" ;
symbol_bind lisp_s2_return_stack_ptr_symbol alloc_i64 return_stack_bottom ;

lisp_register_builtin_function "exit" 1 exit_instruction ;
lisp_register_builtin_function "syscall" 7 syscall_instruction ;
lisp_register_builtin_function "native-call" 1 native_call_instruction ;

lisp_register_builtin_function "read-mem-i64" 1 read_mem_i64_instruction ;
lisp_register_builtin_function "write-mem-i64" 2 write_mem_i64_instruction ;
lisp_register_builtin_function "read-mem-i32" 1 {
    lisp_value_stack_push
    alloc_i64 read_mem_i32 obj_i64_get_value
    lisp_assert_type "read-mem-i32" i64_obj_type_id dup
    lisp_value_stack_pop
} ;
lisp_register_builtin_function "write-mem-i32" 2 {
    lisp_value_stack_push 0
    write_mem_i32 bi@ { obj_i64_get_value }
    bi@ { lisp_assert_type "write-mem-i32" i64_obj_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;
lisp_register_builtin_function "read-mem-byte" 1 read_mem_byte_instruction ;
lisp_register_builtin_function "write-mem-byte" 2 write_mem_byte_instruction ;
lisp_register_builtin_function "memcopy" 3 {
    lisp_value_stack_push 0
    memcopy rot
    obj_i64_get_value
    lisp_assert_type "memcopy src address" i64_obj_type_id dup
    lisp_value_stack_pop 
    obj_i64_get_value
    lisp_assert_type "memcopy dest address" i64_obj_type_id dup
    lisp_value_stack_pop 
    obj_i64_get_value
    lisp_assert_type "memcopy length" i64_obj_type_id dup
    lisp_value_stack_pop 
} ;

lisp_register_builtin_function "bitwise-ior" 2 bitwise_ior_instruction ;
lisp_register_builtin_function "bitwise-lshift" 2 {
    lisp_value_stack_push
    alloc_i64 bit_lshift bi@ { obj_i64_get_value }
    assert "bitwise-ior args are i64" and bi@ { = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_pop lisp_value_stack_pop
} ;

lisp_register_builtin_function "symbol-to-string" 1 {
    lisp_value_stack_push drop lisp_value_stack_pop
    alloc_string_from_buffer bi { symbol_get_size } { symbol_get_buffer }
    lisp_assert_type "symbol-to-string takes symbol as argument" symbol_obj_type_id dup lisp_value_stack_peek_top
} ;

lisp_register_builtin_function "string-to-symbol" 1 {
    lisp_value_stack_push
    byte_vector_destroy
    keep { get_or_create_symbol }
    keep { byte_vector_append_buffer }
    byte_vector_new bi { obj_string_get_size } { obj_string_get_buffer } lisp_value_stack_pop 
    lisp_assert_type "string-to-symbol takes string as argument" string_obj_type_id lisp_value_stack_peek_top
} ;

lisp_register_builtin_function "string-concat" 2 {
    lisp_value_stack_push
    bi { byte_vector_destroy } { alloc_string }
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    keep { byte_vector_append_buffer dip { bi { obj_string_get_size } { obj_string_get_buffer } lisp_value_stack_peek 0 } }
    keep { byte_vector_append_buffer dip { bi { obj_string_get_size } { obj_string_get_buffer } lisp_value_stack_peek 1 } }
    byte_vector_new
    lisp_assert_type "string-concat takes string as second argument" string_obj_type_id lisp_value_stack_peek_top
    lisp_assert_type "string-concat takes string as frist argument" string_obj_type_id lisp_value_stack_peek 1
} ;

lisp_register_builtin_function "string-length" 1 string_length_instruction ;
lisp_register_builtin_function "string-get-byte" 2 string_get_byte_instruction ;
lisp_register_builtin_function "string-to-native-buffer" 2 {
    lisp_value_stack_push 0
    memcopy bi { obj_string_get_size } { obj_string_get_buffer }
    # <string obj> <buffer>
    lisp_assert_type "write-string-to-native-buffer: first arg is string" string_obj_type_id dup lisp_value_stack_pop
    obj_i64_get_value
    lisp_assert_type "write-string-to-native-buffer: second arg (native buffer) is i64" i64_obj_type_id dup lisp_value_stack_pop
} ;
lisp_register_builtin_function "string-from-native-buffer" 2 {
    lisp_value_stack_push alloc_string_from_buffer
    # <length> <buffer>
    swap
    obj_i64_get_value
    assert "native-buffer is i64" lisp_obj_is_i64 dup lisp_value_stack_pop
    obj_i64_get_value
    assert "length is i64" lisp_obj_is_i64 dup lisp_value_stack_pop
} ;
lisp_register_builtin_function "print-function" 1 {
    lisp_value_stack_push 0
    pf_print_function obj_lambda_get_function
    lisp_assert_type "print-function expects lambda arg" lambda_obj_type_id dup
    lisp_value_stack_pop
} ;

lisp_register_builtin_function "enable-eval-debug-logging" 0 {
    lisp_value_stack_push 0
    lisp_eval_debug_enable
} ;

lisp_register_builtin_function "enable-gc-logging" 0 {
    lisp_value_stack_push 0
    lisp_gc_logging_enable
} ;

lisp_register_builtin_function "disable-tco" 0 {
    lisp_value_stack_push 0
    tco_disable
} ;

constant "ptr_to_null" malloc 8 ;
write_mem_i64 ptr_to_null 0 ;

constant "num_child_args" + -2 argc ;
constant "ptr_child_args" malloc * 8 + 1 num_child_args ;
write_mem_i64 + ptr_child_args * 8 num_child_args 0 ;
drop while { > argc dup } {
    + 1
    write_mem_i64 bi { + ptr_child_args * 8 + -2 } { drop swap argv_get_buffer } dup
    # <index>
} 2
;
lisp_register_builtin_function "execve-second-cli-arg" 0 {
    lisp_value_stack_push
    alloc_i64 syscall 59 drop swap argv_get_buffer 2 ptr_child_args ptr_to_null 1 2 3
} ;

constant "lisp_rng" malloc random_instance_size ;
random_init lisp_rng 0 ;

lisp_register_builtin_function "random-int" 0 {
    lisp_value_stack_push alloc_i64 random_next_int lisp_rng
} ;


lisp_register_builtin_function "import" 1 {
    lisp_value_stack_push
    # do not destroy the filename string, it will be stored in buffered_inputs 
    if { } {
        keep { source_file_input_stack_push_file }
    } {
        # already imported
    }
    imports_list_add dup
    # <string> <string obj>
    string_from_buffer bi { obj_string_get_buffer } { obj_string_get_size }
    dup
    lisp_assert_type "import expects string arg" string_obj_type_id dup
    lisp_value_stack_pop
} ;


def "define_instruction_func" { call define_instruction } ;
se_check_last_defined_function ;
def "call_instruction_func" { call call_instruction } ;
# se_check_last_defined_function ;
def "make_cell_instruction_func" { call make_cell_instruction } ;
se_check_last_defined_function ;

def "read_mem_i64_instruction_func" { call read_mem_i64_instruction } ;
se_check_last_defined_function ;
def "read_mem_byte_instruction_func" { call read_mem_byte_instruction } ;
se_check_last_defined_function ;
def "write_mem_i64_instruction_func" { call write_mem_i64_instruction } ;
se_check_last_defined_function ;
def "write_mem_byte_instruction_func" { call write_mem_byte_instruction } ;
se_check_last_defined_function ;
def "bitwise_ior_instruction_func" { call bitwise_ior_instruction } ;
se_check_last_defined_function ;
def "print_string_instruction_func" { call print_string_instruction } ;
se_check_last_defined_function ;

#se_enable ;
se_check_function_by_name "buffered_input_advance" ;
se_check_function_by_name "lisp builtin: string-concat" ;
se_check_function_by_name "lisp builtin: symbol-to-string" ;
se_check_function_by_name "lisp builtin: string-to-symbol" ;
se_check_function_by_name "lisp builtin: second" ;
se_check_function_by_name "lisp builtin: nth" ;
se_check_function_by_name "lisp builtin: import" ;
se_check_function_by_name "lisp builtin: +" ;
se_check_function_by_name "lisp builtin: -" ;
se_check_function_by_name "lisp builtin: /" ;
se_check_function_by_name "lisp builtin: *" ;
se_check_function_by_name "lisp_compile_prepend_remove_temp_values_from_the_stack" ;
se_check_function_by_name "lisp_compile_expression" ;
se_check_function_by_name "symbol_bind" ;
se_check_function_by_name "obj_is_symbol" ;
se_check_function_by_name "lisp_register_builtin_function" ;
se_check_function_by_name "lisp_gc_push_roots_to_stack" ;
se_check_function_by_name "lisp_gc_mark_push_refs_switch" ;
se_check_function_by_name "token_open_paren_couterpart" ;
se_check_function_by_name "read_next_expression" ;
se_check_function_by_name "print_obj" ;
se_check_function_by_name "not_instruction_f" ;
se_check_function_by_name "lisp_gc_sweep" ;
se_check_function_by_name "lisp_assert_type" ;
se_check_function_by_name "alloc_lambda" ;

#constant "cb" code_buffer_new ;
#code_buffer_prepend_code cb { print_string "test\n" } ;
#code_buffer_prepend_code cb { if { true } { assert "tail call if_then" false } { } } ;
#dup code_buffer_make_function_and_destroy cb ;
#name_anon_functions swap "func_name" ;
#jmp ;
#exit 1 ;
#while { true } { print_newline token_print read_next_token } ;
#while { true } { print_newline print_obj lisp_value_stack_pop read_next_expression } ;
while { true } { 
    #.s
    #print_newline print_obj lisp_value_stack_pop
    drop lisp_value_stack_pop
    call lisp_eval
    read_next_expression
} ;
