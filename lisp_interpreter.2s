# import buffered_stdin.2s
# import byte_vector.2s
# import array_list.2s
# import stack_effect.2s
# import switch_stmt.2s
# import lib.2s
# import code_buffer.2s

#se_enable ;

def "string_first_char" {
    byte_vector_get dip { 0 }
} ;
se_check_last_defined_function ;

constant "open_paren_char" string_first_char "(" ;
constant "close_paren_char" string_first_char ")" ;
constant "space_char" string_first_char " " ;
constant "t_char" string_first_char "t" ;
constant "n_char" string_first_char "n" ;
constant "x_char" string_first_char "x" ;
constant "tab_char" string_first_char "\t" ;
constant "hash_char" string_first_char "#" ;
constant "newline_char" string_first_char "\n" ;
constant "semicolon_char" string_first_char ";" ;
constant "double_quote_char" 34 ;
constant "single_quote_char" 39 ;
constant "backquote_char" string_first_char "`" ;
constant "backslash_char" 92 ;

# <char> -> <bool>
def "is_whitespace_char" {
    drop swap
    lazy_or { lazy_or { = space_char dup } = tab_char dup } = newline_char dup
} ;

def "is_paren_char" {
    or bi { = open_paren_char } { = close_paren_char }
} ;

def "skip_whitespace_and_comments" {
    while { lazy_or { = semicolon_char scanner_peek } is_whitespace_char scanner_peek } {
        if { = semicolon_char scanner_peek } {
            while { not = newline_char scanner_peek } { # skip line comment
                scanner_advance
            }
        } {
            scanner_advance # skip whitespace
        }
    }
} ;

constant "token_open_paren_type"            0 ;
constant "token_close_paren_type"           1 ;
constant "token_symbol_or_i64_literal_type" 2 ;
constant "token_string_literal_type"        3 ;
constant "token_char_literal_type"          4 ;
constant "token_backquote_type"             5 ;

# <expr type id> <value> -> <token>
def "token_create" {
    keep { write_mem_i64 + 8 }
    keep { write_mem_i64 }
    malloc * 2 8
} ;
 
# <expr> -> <token type id>
def "token_get_type_id" {
    read_mem_i64
} ;

# <expr> -> <value>
def "token_get_value" {
    read_mem_i64 + 8
} ;

def "token_print_switch"
    when { = token_open_paren_type dup } then { print_string "open paren" 2drop } otherwise
    when { = token_close_paren_type dup } then { print_string "close paren" 2drop } otherwise
    when { = token_symbol_or_i64_literal_type dup } then { print_string "'" print_string token_get_value print_string "symbol or i64 literal: '" drop } otherwise
    when { = token_char_literal_type dup } then { print_string "'" print_string token_get_value print_string "char literal: '" drop } otherwise
    when { = token_string_literal_type dup } then {
        print_string "'" byte_vector_destroy print_string dup decode_string_literal print_string "decoded: '"
        print_string "', " print_string dup token_get_value
        print_string "string literal: '" drop } otherwise
    { assert "bad token type" false 2drop . dup }
;

# <token> ->
def "token_print" {
    token_print_switch
    token_get_type_id dup
} ;

def "token_destroy_switch"
    when { = token_open_paren_type dup } then { free drop } otherwise
    when { = token_close_paren_type dup } then { free drop } otherwise
    when { = token_symbol_or_i64_literal_type dup } then {
        bi { free } { byte_vector_destroy token_get_value } drop
    } otherwise
    when { = token_char_literal_type dup } then {
        bi { free } { byte_vector_destroy token_get_value } drop
    } otherwise
    when { = token_string_literal_type dup } then {
        bi { free } { byte_vector_destroy token_get_value } drop
    } otherwise
    { assert "bad token type" false 2drop . dup }
;

# <token> ->
def "token_destroy" {
    token_destroy_switch
    token_get_type_id dup
} ;

def "scanner_peek" {
    buffered_stdin_peek_byte
} ;

def "scanner_advance" {
    drop buffered_stdin_read_byte
} ;

def "read_next_token_symbol_or_number" {
    token_create token_symbol_or_i64_literal_type
    while { lazy_and { not is_paren_char scanner_peek } not is_whitespace_char scanner_peek } {
        scanner_advance
        keep { byte_vector_append dip { scanner_peek } } 
    }
    byte_vector_new
} ;

def "is_double_quote_or_newline" { or bi { = double_quote_char } { = newline_char } } ;

# -> <token>
def "read_next_token_double_quote" {
    token_create token_string_literal_type
    scanner_advance
    assert "no newline in string literals" not = newline_char scanner_peek
    while { not is_double_quote_or_newline scanner_peek } {
        scanner_advance
        if { = backslash_char scanner_peek } {
            keep { byte_vector_append dip { scanner_peek } } 
            scanner_advance
        } { }
        keep { byte_vector_append dip { scanner_peek } } 
    }
    scanner_advance
    byte_vector_new
} ;

# -> <token> # scanner on the char's position
def "read_next_token_switch"
    when { = single_quote_char scanner_peek } then {
        token_create token_backquote_type 0
        scanner_advance
    } otherwise
    when { = open_paren_char scanner_peek } then {
        token_create token_open_paren_type 0
        scanner_advance
    } otherwise
    when { = close_paren_char scanner_peek } then {
        token_create token_close_paren_type 0
        scanner_advance
    } otherwise
    when { = double_quote_char scanner_peek } then { read_next_token_double_quote } otherwise
    { read_next_token_symbol_or_number }
;

# -> <token>
def "read_next_token" {
    read_next_token_switch
    skip_whitespace_and_comments
} ;
se_check_last_defined_function ;

# <char> -> <char>
def "decode_escaped_char" 
    when { = string_first_char "t" dup } then { tab_char drop } otherwise
    when { = string_first_char "n" dup } then { newline_char drop } otherwise
    when { = double_quote_char dup } then { double_quote_char drop } otherwise
    when { = backslash_char dup } then { backslash_char drop } otherwise
    { 0 assert "no bad chars" false print_newline . }
;
# <string> -> <string>
def "decode_string_literal" {
    dip { 2drop }
    while { swap dip { > byte_vector_get_size 2dup } } {
        keep { byte_vector_append }
        dip {
            2dip { + 1 }
            if { = backslash_char dup } {
                decode_escaped_char byte_vector_get 2dup
                dip { + 1 }
                drop
            } { }
            byte_vector_get 2dup
        }
    }
    # <new string> <original string> <index>
    byte_vector_new dip { 0 }
} ;
se_check_last_defined_function ;

# Lisp objects
#
# Every object has a 8-byte header
# Object header structure: [type_id: i64][gc_marked_flag (0 or 1) i64]
#
# Types
#   symbol:
#       type_id: 0
#       structure: [length: i64][string_buffer: variable]
#   i64:
#       type_id: 1
#       structure: [value: i64]
#   pair:
#       type_id: 2
#       structure: [car: pointer][cdr: pointer]
#   nil:
#       null pointer
#
#   Symbols
#       Symbols are interned strings and are not freed by GC

constant "obj_type_names" array_list_new ;

constant "symbol_obj_type_id"   0 ;
array_list_append obj_type_names "symbol" ;
constant "i64_obj_type_id"      1 ;
array_list_append obj_type_names "i64" ;
constant "pair_obj_type_id"     2 ;
array_list_append obj_type_names "pair" ;
constant "lambda_obj_type_id"   3 ;
array_list_append obj_type_names "lambda" ;
constant "env_obj_type_id"      4 ;
array_list_append obj_type_names "env" ;
constant "bool_obj_type_id"     5 ;
array_list_append obj_type_names "bool" ;
constant "cell_obj_type_id"     6 ;
array_list_append obj_type_names "cell" ;
constant "string_obj_type_id"   7 ;
array_list_append obj_type_names "string" ;
constant "builtin_func_obj_type_id"   8 ;
array_list_append obj_type_names "builtin_func" ;


# <type id> -> <string>
def "obj_type_name" {
    array_list_get obj_type_names
} ;

constant "obj_header_size" 16 ;

# <obj ptr> <type_id> ->
def "obj_set_type_id" {
    write_mem_i64
} ;

# <obj ptr> ->
def "obj_get_type_id" {
    read_mem_i64
} ;

# <obj ptr> <type_id> ->
def "obj_set_gc_marked_flag" {
    write_mem_i64 + 8
} ;

# <obj ptr> ->
def "obj_get_gc_marked_flag" {
    read_mem_i64 + 8
} ;

# <string> -> <symbol>
def "alloc_symbol" {
    keep {
        memcopy bi { byte_vector_get_size } { byte_vector_get_array } swap # <symbol_obj_buf ptr> <string>
        + 24
        write_mem_i64 dip { byte_vector_get_size } 2dup
        + obj_header_size
    }
    keep { write_mem_i64 swap 0 + 16 + obj_header_size }
    keep { write_mem_i64 swap false + 8 + obj_header_size }
    obj_set_type_id swap symbol_obj_type_id dup
    # <symbol ptr> <string>
    malloc + * 8 3 + obj_header_size byte_vector_get_size dup
} ;
se_check_last_defined_function ;

def "symbol_get_size" {
    read_mem_i64 + obj_header_size
} ;

def "symbol_has_binding" {
    read_mem_i64 + 8 + obj_header_size
} ;

# <symbol> <bool> -> 
def "symbol_set_binding_flag" {
    write_mem_i64 + 8 + obj_header_size
} ;

def "symbol_get_binding" {
    read_mem_i64 + 16 + obj_header_size
} ;

# <symbol> <value> -> 
def "symbol_set_binding" {
    write_mem_i64 + 16 + obj_header_size
} ;

def "symbol_get_buffer" {
    + 24 + obj_header_size
} ;

# <symbol> <value> -> 
def "symbol_bind" {
    symbol_set_binding
    keep { symbol_set_binding_flag swap true }
    if { symbol_has_binding dup } {
        exit 1
        print_newline
        print_obj symbol_get_binding dup
        print_string "is already bound to "
        print_obj dup
        print_string "symbol "
    } { }
} ;

# <symbol> -> 
def "symbol_unbind" {
    symbol_set_binding_flag swap false
} ;

# <buffer> <size>
def "print_buffer" {
    assert "buffer is fully written" =
    dip {
        panic_on_syscall_error
        syscall 1 1 2dip { 1 2 3 }
    }
    over
} ;

constant "symbol_list" array_list_new ;

# <symbol> <string> -> <bool>
def "symbol_name_equal" {
    if { = bi* { symbol_get_size } { byte_vector_get_size } 2dup } {
        = 0 memcmp dip { bi* { symbol_get_buffer } { byte_vector_get_array } } symbol_get_size dup
    } {
        false 2drop
    }
} ;
se_check_last_defined_function ;

# <string> -> <symbol>
def "get_or_create_symbol" {
    if { = array_list_get_size symbol_list dup } {
        array_list_append symbol_list dup alloc_symbol drop
    } {
        array_list_get symbol_list dip { drop }
    }
    while { lazy_and { not symbol_name_equal array_list_get symbol_list 2dup } > array_list_get_size symbol_list dup } {
        + 1
    }
    0
} ;
se_check_last_defined_function ;

# <number> -> <obj>
def "alloc_i64" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap i64_obj_type_id }
    malloc + 8 obj_header_size
    lisp_run_gc
} ;

# <obj> -> <value>
def "obj_i64_get_value" {
    read_mem_i64 + obj_header_size
} ;

# <car obj> <cdr obj> -> <pair obj>
def "alloc_pair" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + 8 + obj_header_size }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap pair_obj_type_id }
    malloc + 16 obj_header_size
    lisp_run_gc
} ;

# <obj> -> <value>
def "obj_pair_car" {
    read_mem_i64 + obj_header_size
    assert "car: obj is pair" = pair_obj_type_id obj_get_type_id dup
    assert "car: obj is not nil" not = 0 dup
} ;

# <obj> -> <value>
def "obj_pair_cdr" {
    read_mem_i64 + 8 + obj_header_size
    assert "cdr: obj is pair" = pair_obj_type_id obj_get_type_id dup
    assert "cdr: obj is not nil" not = 0 dup
} ;

def "obj_pair_invalidate" {
    write_mem_i64 swap -1 + 8 + obj_header_size
    write_mem_i64 swap -1 + obj_header_size dup
} ;
se_check_last_defined_function ;

# <obj> -> <bool>
def "obj_is_pair" {
    if { = 0 dup } {
        false drop
    } {
        = pair_obj_type_id obj_get_type_id
    }
} ;

# <obj> -> <bool>
def "obj_is_list" {
    = 0 while { obj_is_pair dup } { obj_pair_cdr }
} ;

def "obj_list_length" {
    drop
    while { not = 0 dup } {
        dip { + 1 }
        obj_pair_cdr
    }
    dip { 0 }
    assert "obj is list" obj_is_list dup
} ;

# lambda layout [header, local env, arg list, body, id]
# <local env stack> <arg list> <body> -> <lambda>
def "alloc_lambda" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 swap 0 + 24 + obj_header_size }
    keep { write_mem_i64 + 16 + obj_header_size }
    keep { write_mem_i64 + 8 + obj_header_size }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap lambda_obj_type_id }
    malloc + 24 obj_header_size
    lisp_run_gc
} ;

def "obj_lambda_get_local_env" { read_mem_i64 + obj_header_size } ;
def "obj_lambda_get_arg_list" { read_mem_i64 + 8 + obj_header_size } ;
def "obj_lambda_get_body" { read_mem_i64 + 16 + obj_header_size } ;
def "obj_lambda_get_id" { read_mem_i64 + 24 + obj_header_size } ;
def "obj_lambda_set_id" { write_mem_i64 + 24 + obj_header_size } ;

def "obj_lambda_invalidate" {
    drop
    write_mem_i64 swap -1 + 24 + obj_header_size dup
    write_mem_i64 swap -1 + 16 + obj_header_size dup
    write_mem_i64 swap -1 + 8 + obj_header_size dup
    write_mem_i64 swap -1 + obj_header_size dup
} ;
se_check_last_defined_function ;

# <bindings list> ->
def "alloc_env" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + obj_header_size } # bindings list is set here
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap env_obj_type_id }
    malloc + 8 obj_header_size
    lisp_run_gc
} ;

def "obj_env_get_bindings" { read_mem_i64 + obj_header_size } ;

# <env> <symbol> <value> -> 
def "obj_env_add_binding" {
    array_list_append
    keep { array_list_append }
    obj_env_get_bindings
    dip { swap }
} ;
se_check_last_defined_function ;

def "obj_env_invalidate" {
    write_mem_i64 swap -1 + obj_header_size
} ;
se_check_last_defined_function ;

def "alloc_bool" {
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap bool_obj_type_id }
    malloc obj_header_size
} ;

constant "obj_bool_true" alloc_bool ;
constant "obj_bool_false" alloc_bool ;

constant "lisp_true_symbol" get_or_create_symbol "#t" ;
constant "lisp_false_symbol" get_or_create_symbol "#f" ;

symbol_bind lisp_true_symbol obj_bool_true ;
symbol_bind lisp_false_symbol obj_bool_false ;

# <obj> -> <cell>
def "alloc_cell" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap cell_obj_type_id }
    malloc + 8 obj_header_size
    lisp_run_gc
} ;

def "obj_cell_get" {
    read_mem_i64 + obj_header_size
} ;

def "obj_cell_set" {
    write_mem_i64 + obj_header_size
} ;

def "obj_cell_invalidate" {
    write_mem_i64 swap -1 + obj_header_size
} ;

# <length> <buffer> -> <obj>
def "alloc_string_from_buffer" {
    keep {
        memcopy -rot
        + 8
        write_mem_i64 2dup
        + obj_header_size
        # <string obj> <length> <buffer>
    }
    keep { obj_set_gc_marked_flag swap false }
    keep { obj_set_type_id swap string_obj_type_id }
    # <string obj ptr> <string>
    malloc + 8 + obj_header_size dup
} ;

# <string> -> <obj>
def "alloc_string" {
    alloc_string_from_buffer bi { byte_vector_get_size } { byte_vector_get_array }
} ;

# <string obj> -> <i64>
def "obj_string_get_size" {
    read_mem_i64 + obj_header_size
} ;

# <string obj> -> <buffer>
def "obj_string_get_buffer" {
    + 8 + obj_header_size
} ;

# <string obj> <string obj> -> <bool>
def "obj_string_eq" {
    dip { 2drop }
    lazy_and {
        = 0
        memcmp 
        dip { bi@ { obj_string_get_buffer } }
        obj_string_get_size dup 
        2dup
    } = bi@ { obj_string_get_size } 2dup
    assert "string-equals args are strings" and bi@ { = string_obj_type_id obj_get_type_id } 2dup
} ;

# <name> <arg count> <instruction>
def "alloc_builtin_func" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + 16 + obj_header_size }
    keep { write_mem_i64 + 8 + obj_header_size }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap builtin_func_obj_type_id }
    malloc + 24 obj_header_size
    lisp_run_gc
} ;

# <obj> -> <value>
def "obj_builtin_get_name" {
    read_mem_i64 + obj_header_size
} ;

# <obj> -> <value>
def "obj_builtin_get_arg_count" {
    read_mem_i64 + 8 + obj_header_size
} ;

# <obj> -> <value>
def "obj_builtin_get_instruction" {
    read_mem_i64 + 16 + obj_header_size
} ;

def "print_obj_quoted"
    when { = 0 dup } then { print_string "nil" drop } otherwise
    when { = obj_bool_true dup } then { print_string "true" drop } otherwise
    when { = obj_bool_false dup } then { print_string "false" drop } otherwise
    when { obj_is_list dup } then {
        if { lazy_and { = lisp_quote_symbol obj_pair_car dup } = 2 obj_list_length dup } {
            print_obj_quoted obj_pair_car obj_pair_cdr
            print_string "'"
        } {
            print_string ")"
            drop
            while { not = 0 dup } {
                if { not = 0 dup } { print_string " " } { }
                obj_pair_cdr
                print_obj_quoted obj_pair_car dup
            }
            print_string "("
        }
    } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then { print_buffer bi { symbol_get_buffer } { symbol_get_size } } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then { . obj_i64_get_value } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        print_obj obj_pair_cdr
        print_string " . "
        print_obj obj_pair_car dup
        print_string "("
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        print_obj obj_lambda_get_body
        print_string " "
        print_obj obj_lambda_get_arg_list dup
        print_string " "
        print_obj obj_lambda_get_local_env dup
        print_string " "
        print_obj obj_lambda_get_id dup
        print_string "(lambda "
    } otherwise
    when { = env_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        2drop
        while { < 0 dup } {
            if { = 0 dup } {
            } {
                print_string " "
            }
            print_string ")"
            print_obj
            array_list_get swap 2dup
            + -1
            print_string " . "
            print_obj
            array_list_get swap 2dup
            + -1
            print_string "("
        }
        array_list_get_size dup
        obj_env_get_bindings
        print_string "(env "
    } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        print_obj obj_cell_get
        print_string "(cell "
    } otherwise
    when { = string_obj_type_id obj_get_type_id dup } then {
        write_byte_to_stdout double_quote_char
        print_buffer bi { obj_string_get_buffer } { obj_string_get_size }
        write_byte_to_stdout double_quote_char
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then {
        print_string ">"
        print_string obj_builtin_get_name
        print_string "<builtin function "
    } otherwise
    { assert "OK" false print_newline . obj_get_type_id print_string "print_obj_quoted: unsuppoted obj type: " }
;

def "print_obj"
    when { = 0 dup } then { print_string "nil" drop } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then {
        print_obj_quoted print_string "'"
    } otherwise
    when { obj_is_list dup } then {
        print_obj_quoted print_string "'"
    } otherwise
    { print_obj_quoted }
;

# <obj> ->
def "destroy_obj"
    when { = bool_obj_type_id obj_get_type_id dup } then { drop } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then { drop } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then {
        free
    } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        free
        obj_pair_invalidate dup
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then {
        free
        obj_lambda_invalidate dup
    } otherwise
    when { = env_obj_type_id obj_get_type_id dup } then {
        free
        obj_env_invalidate dup
        array_list_destroy obj_env_get_bindings dup
    } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        free
        obj_cell_invalidate dup
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then { drop } otherwise
    { assert "suppoted obj type" false print_newline . obj_get_type_id }
;
se_check_last_defined_function ;


# <obj> <obj> -> <bool>
def "obj_equal_switch"
    when { = bool_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then {
        = bi@ { obj_i64_get_value }
    } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        dip { 2drop }
        lazy_and { obj_equal bi@ { obj_pair_cdr } 2dup }
        obj_equal bi@ { obj_pair_car } 2dup
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = env_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        obj_equal bi@ { obj_cell_get }
    } otherwise
    when { = string_obj_type_id obj_get_type_id dup } then {
        obj_string_eq
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then { = } otherwise
    { false assert "suppoted obj type" false drop print_newline . obj_get_type_id }
 ;

# <obj> <obj> -> <bool>
def "obj_equal" {
    if { = 2dup } {
        true 2drop
    } {
        if { lazy_and { = bi@ { obj_get_type_id } 2dup } and bi@ { not = 0 } 2dup } {
            obj_equal_switch
        } {
            false 2drop
        }
    }
} ;
se_check_last_defined_function ;

constant "current_token_ptr" malloc 8 ;

def "token_scanner_advance" {
    write_mem_i64 current_token_ptr 0
} ;
def "token_scanner_peek" {
    read_mem_i64 current_token_ptr
    if { = read_mem_i64 current_token_ptr 0 } {
        write_mem_i64 current_token_ptr read_next_token
    } { }
} ;


# <char*> <size> -> <bool> <number>
def "parse_i64_non_empty" {
    2drop # <char* end> <char*> <bool> <number>
    if { = 45 read_mem_byte over } {
        # negative
        if { = 2dup } {
            2dip { false drop } # single "-" case
        } {
            while { lazy_and { rot 2dip { dup } } > 2dup } {
                dip {
                    + 1 # <char*> <bool> <number>
                    if { and bi { <= 48 } { > 58 } read_mem_byte dup } {
                        keep {
                            and
                            dip { checked_add * -1 + -48 read_mem_byte }
                            swap
                        } # <char*> <bool> <number>
                        dip { checked_mul 10 drop }
                    } {
                        dip { false drop }
                    }
                }
            }
        }
        dip { + 1 }
    } {
        # positive
        while { lazy_and { rot 2dip { dup } } > 2dup } {
            dip {
                + 1 # <char*> <bool> <number>
                if { and bi { <= 48 } { > 58 } read_mem_byte dup } {
                    keep {
                        and
                        dip { checked_add + -48 read_mem_byte }
                        swap
                    } # <char*> <bool> <number>
                    dip { checked_mul 10 drop }
                } {
                    dip { false drop }
                }
            }
        }
    }
    # <char* end> <char*> <bool> <number>
    swap keep { + }
    2dip { true 0 }
} ;

# <char*> <size> -> <bool> <number>
def "parse_i64" {
    if { < 0 over } {
        parse_i64_non_empty
    } {
        false 0 2drop
    }
} ;

# <buffer> <number> ->
def "render_i64" {
    2drop
    if { > 0 over } {
        # negative
        write_mem_byte swap 45 dup
        while { not = 0 over } {
            + -1 dip { / swap 10 }
            2keep { 
                write_mem_byte dip { + 48 * -1 % swap 10 }
            }
        }
        + -1 dip { / swap 10 }
        2keep { 
            write_mem_byte dip { + 48 * -1 % swap 10 }
        }
    } {
        # positive
        while { not = 0 over } {
            + -1 dip { / swap 10 }
            2keep { 
                write_mem_byte dip { + 48 % swap 10 }
            }
        }
        + -1 dip { / swap 10 }
        2keep { 
            write_mem_byte dip { + 48 % swap 10 }
        }
    }
    # <buffer end> <number>
    + dip { + -1 i64_text_length dup }
} ;

# <number> -> <length>
def "i64_text_length" {
    drop swap
    while { not = 0 over }  {
        + 1 dip { / swap 10 }
    }
        + 1 dip { / swap 10 }
    # <length> <number>
    if { > 0 dup } { 1 } { 0 }
} ;

def "parse_i64_string" {
    parse_i64 bi { byte_vector_get_array } { byte_vector_get_size }
} ;

# <byte> -> <bool>
def "is_hex_digit" {
    drop r>
    or
        and > 103 r@ <= 97 r@
        and > 58 r@ <= 48 r@
    >r
} ;

# <byte> -> <number>
def "parse_hex_digit" {
    if { > 58 dup } {
        + -48
    } {
        + -87
    }
} ;

# <char*> <size> -> <bool> <number>
def "parse_hex_i64" {
    if { lazy_and { <= 3 over } >= 18 over } {
        if { lazy_and { = hash_char read_mem_byte dup } = x_char read_mem_byte + 1 dup } {
            2drop
            while { lazy_and { rot 2dip { dup } } > 2dup } {
                dip {
                    + 1
                    keep {
                        if { is_hex_digit read_mem_byte dup } {
                            true
                            + parse_hex_digit read_mem_byte
                            dip { * 16 }
                        } {
                            false drop
                        }
                    }
                    # <current char*> <number>
                    dip { drop }
                }
            }
            # <end char*> <current char*> <bool> <number>
            2dip { true 0 }
            swap
            + 2 # skip prefix
            keep { + }
        } {
            false 0 2drop # wrong prefix
        }
    } {
        false 0 2drop # wrong size
    }
} ;


def "parse_hex_i64_string" {
    parse_hex_i64 bi { byte_vector_get_array } { byte_vector_get_size }
} ;
se_check_last_defined_function ;

constant "lisp_value_stack" array_list_new ;

def "lisp_value_stack_push" {
    array_list_append lisp_value_stack
} ;

def "lisp_value_stack_pop" {
    array_list_pop_last lisp_value_stack
} ;

def "lisp_value_stack_peek_top" {
    array_list_get_last lisp_value_stack
} ;

def "lisp_value_stack_peek" {
    array_list_peek lisp_value_stack
} ;

# <n> ->
def "lisp_value_drop_swap_n_times" {
    array_list_set_size lisp_value_stack - array_list_get_size lisp_value_stack 
    array_list_set lisp_value_stack + -1 - array_list_get_size lisp_value_stack dip { lisp_value_stack_peek_top } dup
} ;
se_check_last_defined_function ;

# <n> ->
def "lisp_value_stack_peek_n_and_push" {
    array_list_append lisp_value_stack
    array_list_get lisp_value_stack + -1 - array_list_get_size lisp_value_stack 
} ;
se_check_last_defined_function ;

def "lisp_value_stack_print" {
    print_string "value stack end\n"
    drop while { <= 0 dup } {
        + -1
        print_newline print_obj array_list_get lisp_value_stack dup
        print_string "value stack> "
    } + -1 array_list_get_size lisp_value_stack
    print_string "value stack:\n"
} ;

constant "lisp_code_literal_list" array_list_new ;

def "lisp_code_literal_list_add" {
    array_list_append lisp_code_literal_list
} ;

# <description str> <type id> <obj>
def "lisp_assert_type" {
    if { lazy_and { = obj_get_type_id 2dup } not = 0 dup } {
        drop 2drop
    } {
        exit 1
        print_newline
        print_obj
        print_string " but was "
        print_string obj_type_name
        print_string ": type assertion failed, expected "
        print_string
        rot
        # <type id> <obj> <str>
        swap
    }
    # <obj> <type id> <str>
    swap
    -rot
} ;

constant "lisp_gc_logging_enabled_pointer" malloc 8 ;
write_mem_i64 lisp_gc_logging_enabled_pointer false ;
def "lisp_gc_logging_is_enabled" { read_mem_i64 lisp_gc_logging_enabled_pointer } ;
def "lisp_gc_logging_enable" { write_mem_i64 lisp_gc_logging_enabled_pointer true } ;

constant "lisp_gc_ref_list" array_list_new ;
def "lisp_gc_ref_list_append" {
    array_list_append lisp_gc_ref_list
    if { lisp_gc_logging_is_enabled } {
        print_newline print_obj print_string "allocation: " dup
        print_newline . array_list_get_size lisp_gc_ref_list print_string "allocation: number of alive objs: "
    } { }
} ;

constant "lisp_gc_marker_stack" array_list_new ;

# <obj> ->
def "lisp_gc_marker_stack_push" {
    if { lazy_or { obj_get_gc_marked_flag dup } = 0 dup } {
        drop # do nothing, obj was marked
    } {
        array_list_append lisp_gc_marker_stack
    }
} ;

def "lisp_gc_push_roots_to_stack" {
    lisp_gc_marker_stack_push get_temp_lambda
    drop while { < 0 dup } {
        if { symbol_has_binding dup } {
            lisp_gc_marker_stack_push symbol_get_binding # push bindings
        } { drop }
        array_list_get symbol_list dup
        + -1
    } array_list_get_size symbol_list
    drop while { < 0 dup } {
        lisp_gc_marker_stack_push array_list_get lisp_code_literal_list dup # push code literals
        + -1
    } array_list_get_size lisp_code_literal_list
    drop while { < 0 dup } {
        lisp_gc_marker_stack_push array_list_get lisp_value_stack dup # push value stack
        + -1
    } array_list_get_size lisp_value_stack
} ;

# <obj> ->
def "lisp_gc_mark_push_refs_switch" 
    when { = bool_obj_type_id obj_get_type_id dup } then {
        drop # do nothing
    } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then {
        if { symbol_has_binding dup } {
            lisp_gc_marker_stack_push symbol_get_binding 
        } {
            drop
        }
    } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then {
        drop
    } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        lisp_gc_marker_stack_push obj_pair_cdr
        lisp_gc_marker_stack_push obj_pair_car dup
    } otherwise
    when { = env_obj_type_id obj_get_type_id dup } then {
        2drop while { < 0 dup } {
            lisp_gc_marker_stack_push array_list_get swap 2dup
            + -2
        } array_list_get_size dup
        obj_env_get_bindings
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then {
        lisp_gc_marker_stack_push obj_lambda_get_body
        lisp_gc_marker_stack_push obj_lambda_get_arg_list dup
        lisp_gc_marker_stack_push obj_lambda_get_local_env dup
    } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        lisp_gc_marker_stack_push obj_cell_get
    } otherwise
    when { = string_obj_type_id obj_get_type_id dup } then {
        drop
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then {
        drop
    } otherwise
    { exit 1 print_newline . obj_get_type_id print_string "gc mark: bad object, obj type:" }
;
se_check_last_defined_function ;

def "lisp_gc_mark" {
    while { not array_list_is_empty lisp_gc_marker_stack } {
        lisp_gc_mark_push_refs_switch
        obj_set_gc_marked_flag swap true dup
        array_list_pop_last lisp_gc_marker_stack
    }
    lisp_gc_push_roots_to_stack 
} ;

def "lisp_gc_sweep" {
    drop while { < 0 dup } {
        if { not obj_get_gc_marked_flag array_list_get lisp_gc_ref_list dup } {
            if { = + -1 array_list_get_size lisp_gc_ref_list dup } { # if last in ref list
                destroy_obj array_list_pop_last lisp_gc_ref_list
            } {
                array_list_set lisp_gc_ref_list dip { array_list_pop_last lisp_gc_ref_list } dup # replace destroyed obj with last from ref list 
                destroy_obj array_list_get lisp_gc_ref_list dup
            }
        } {
            obj_set_gc_marked_flag swap false array_list_get lisp_gc_ref_list dup
        }
        + -1
    } array_list_get_size lisp_gc_ref_list
    if { lisp_gc_logging_is_enabled } {
        drop while { < 0 dup } {
            if { not obj_get_gc_marked_flag dup } {
                print_newline print_obj print_string "gc: will remove "
            } { drop }
            array_list_get lisp_gc_ref_list dup
            + -1
        } array_list_get_size lisp_gc_ref_list
    } { }
} ;

def "lisp_obj_count" { array_list_get_size lisp_gc_ref_list } ;

constant "lisp_previous_obj_count_ptr" malloc 8 ;
def "lisp_previous_obj_count" { read_mem_i64 lisp_previous_obj_count_ptr } ;
def "lisp_previous_obj_count_set" { write_mem_i64 lisp_previous_obj_count_ptr } ;

lisp_previous_obj_count_set 0 ;

def "lisp_run_gc" {
    if { < * 2 lisp_previous_obj_count lisp_obj_count } {
        lisp_previous_obj_count_set lisp_obj_count
        lisp_gc_sweep
        lisp_gc_mark
    } { }
} ;

def "read_next_expression_switch"
    when { = token_backquote_type token_get_type_id token_scanner_peek } then {
        lisp_value_stack_push drop lisp_value_stack_pop
        alloc_pair lisp_quote_symbol lisp_value_stack_peek_top
        lisp_value_stack_push drop lisp_value_stack_pop
        alloc_pair lisp_value_stack_peek_top 0
        read_next_expression
        token_scanner_advance
    } otherwise
    when { = token_open_paren_type token_get_type_id token_scanner_peek } then {
        drop
        while { < 0 dup } {
            lisp_value_stack_push
            drop lisp_value_stack_pop
            drop lisp_value_stack_pop
            alloc_pair lisp_value_stack_peek 1 lisp_value_stack_peek 0
            + -1
        }
        lisp_value_stack_push 0
        token_scanner_advance
        while { not = token_close_paren_type token_get_type_id token_scanner_peek } {
            + 1
            read_next_expression
        }
        0
        token_scanner_advance
    } otherwise
    when { = token_symbol_or_i64_literal_type token_get_type_id token_scanner_peek } then {
        token_scanner_advance
        token_destroy token_scanner_peek
        if { } {
            lisp_value_stack_push alloc_i64
        } {
            if { } {
                lisp_value_stack_push alloc_i64
            } {
                lisp_value_stack_push get_or_create_symbol token_get_value token_scanner_peek drop
            }
            parse_hex_i64_string token_get_value token_scanner_peek
            drop
        }
        parse_i64_string token_get_value token_scanner_peek
    } otherwise
    when { = token_string_literal_type token_get_type_id token_scanner_peek } then {
        token_scanner_advance
        token_destroy token_scanner_peek
        lisp_value_stack_push alloc_string token_get_value token_scanner_peek
    } otherwise
    when { = token_close_paren_type token_get_type_id token_scanner_peek } then {
        exit 1
        print_string "parsing error: unexpected close paren\n"
    } otherwise
    { assert "suppoted literal type" false print_newline . token_get_type_id token_scanner_peek }
;

def "read_next_expression" {
    read_next_expression_switch
} ;

# <obj> <obj> -> <obj>
def "obj_i64_add" {
    alloc_i64 + bi@ { obj_i64_get_value }
    bi@ { assert "'add' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
} ;

# <name> <func>
def "register_lisp_instruction" {
    def string_concat swap "_f"
    constant 2dup
} ;

register_lisp_instruction "obj_i64_add_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    obj_i64_add lisp_value_stack_peek 1 lisp_value_stack_peek 0
} ;

register_lisp_instruction "obj_i64_sub_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_i64 - bi@ { obj_i64_get_value }
    bi@ { assert "'sub' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

register_lisp_instruction "obj_i64_mul_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_i64 * bi@ { obj_i64_get_value }
    bi@ { assert "'mul' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 1 lisp_value_stack_peek 0
} ;

register_lisp_instruction "obj_i64_div_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_i64 / bi@ { obj_i64_get_value }
    bi@ { assert "'div' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

register_lisp_instruction "obj_i64_gt_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    if { > bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { assert "'gt' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

register_lisp_instruction "obj_i64_lt_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    if { < bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { assert "'lt' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

register_lisp_instruction "obj_i64_gte_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    if { >= bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { assert "'>=' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

register_lisp_instruction "obj_i64_lte_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    if { <= bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { assert "'<=' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

register_lisp_instruction "literal_instruction" {
    lisp_value_stack_push lisp_program_stack_pop
} ;

register_lisp_instruction "drop_instruction" {
    drop lisp_value_stack_pop
} ;

register_lisp_instruction "define_instruction" {
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    symbol_bind
    if { lazy_and { = lambda_obj_type_id obj_get_type_id over } not = 0 over } {
        obj_lambda_set_id swap 2dup
    } { }
    # <symbol> <value>
    lisp_value_stack_peek 0 # symbol
    lisp_value_stack_peek 1 # value
    if { symbol_has_binding lisp_value_stack_peek 0 } {
        exit 1
        print_newline
        print_obj lisp_value_stack_peek 0
        print_string "symbol is already defined: "
    } { }
} ;

register_lisp_instruction "make_lambda_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_lambda
        lisp_value_stack_peek 0 # local env
        lisp_value_stack_peek 1 # arg list
        lisp_value_stack_peek 2 # body
    assert "local env is env" = env_obj_type_id obj_get_type_id lisp_value_stack_peek 0 # local env
    assert "arg list is list" obj_is_list lisp_value_stack_peek 1 # arg list
} ;

constant "temp_lambda_ptr" malloc 8 ;

def "set_temp_lambda" {
    write_mem_i64 temp_lambda_ptr
} ;

def "get_temp_lambda" {
    read_mem_i64 temp_lambda_ptr
} ;
set_temp_lambda 0 ;


register_lisp_instruction "car_instruction" {
    if { obj_is_pair lisp_value_stack_peek_top } {
        lisp_value_stack_push obj_pair_car lisp_value_stack_pop
    } {
        exit 1
        lisp_print_stack_trace
        print_newline print_obj lisp_value_stack_peek_top
        print_string "error: car of obj: "
    }
} ;

register_lisp_instruction "cdr_instruction" {
    lisp_value_stack_push obj_pair_cdr lisp_value_stack_pop
} ;

register_lisp_instruction "cons_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_pair lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

register_lisp_instruction "read_syntax_instruction" {
    read_next_expression
} ;

register_lisp_instruction "print_instruction" {
    lisp_value_stack_push 0
    print_obj lisp_value_stack_pop
} ;

# <char> -> <char>
def "unescape_string_char"
    when { = t_char dup } then {
        tab_char drop
    } otherwise
    when { = n_char dup } then {
        newline_char drop
    } otherwise
    { 0 exit 1 write_byte_to_stdout print_string "bad char in string: " }
;
se_check_last_defined_function ;

register_lisp_instruction "print_string_instruction" {
    lisp_value_stack_push 0
    3drop
    while { > 2dup } {
        dip {
            + 1
            if { = backslash_char read_mem_byte + 2dup } {
                write_byte_to_stdout unescape_string_char read_mem_byte + 2dup
                + 1
            } {
                write_byte_to_stdout read_mem_byte + 2dup
            }
        }
    } # <size> <index> <buffer>
    dip { 0 }
    bi { obj_string_get_size } { obj_string_get_buffer }
    lisp_value_stack_pop
    assert "print-string arg is string" = string_obj_type_id obj_get_type_id lisp_value_stack_peek_top
} ;

register_lisp_instruction "make_cell_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    alloc_cell lisp_value_stack_peek_top
} ;

register_lisp_instruction "cell_get_instruction" {
    lisp_value_stack_push obj_cell_get lisp_value_stack_pop
} ;

register_lisp_instruction "cell_set_instruction" {
    lisp_value_stack_push 0
    obj_cell_set swap lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "exit_instruction" {
    lisp_value_stack_push 0
    exit obj_i64_get_value lisp_value_stack_pop
    assert "exit arg is i64" = i64_obj_type_id obj_get_type_id lisp_value_stack_peek_top
} ;

register_lisp_instruction "equals_instruction" {
    if { obj_equal lisp_value_stack_pop lisp_value_stack_pop } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
} ;

register_lisp_instruction "not_instruction" {
    lisp_value_stack_push
    if { = obj_bool_false } {
        obj_bool_true
    } {
        obj_bool_false
    }
    if { not lazy_or { = obj_bool_true dup } = obj_bool_false dup } {
        exit 1
        lisp_print_stack_trace
        print_newline
        print_obj dup
        print_string "'not' on non-boolean obj: "
    } { }
    lisp_value_stack_pop
} ;

register_lisp_instruction "list_q_instruction" {
    if { obj_is_list lisp_value_stack_pop } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
} ;

# <obj> -> <bool>
def "lisp_obj_is_i64" {
    drop swap
    lazy_and { = i64_obj_type_id obj_get_type_id dup } not = 0 dup
} ;
se_check_last_defined_function ;

def "syscall_pop_i64" {
    obj_i64_get_value lisp_value_stack_pop
    assert "syscall arg is i64" lisp_obj_is_i64 lisp_value_stack_peek_top
} ;

register_lisp_instruction "syscall_instruction" {
    lisp_value_stack_push alloc_i64 syscall
    dip {
    dip {
    dip {
    dip {
    dip {
    dip {
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
} ;

register_lisp_instruction "native_call_instruction" {
    lisp_value_stack_push
    alloc_i64 native_call obj_i64_get_value
    assert "native-call arg is i64" = i64_obj_type_id obj_get_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "read_mem_i64_instruction" {
    lisp_value_stack_push
    alloc_i64 read_mem_i64 obj_i64_get_value
    lisp_assert_type "read-mem-i64" i64_obj_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "write_mem_i64_instruction" {
    lisp_value_stack_push 0
    write_mem_i64 bi@ { obj_i64_get_value }
    bi@ { lisp_assert_type "write-mem-i64" i64_obj_type_id } 2dup
    swap lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "read_mem_byte_instruction" {
    lisp_value_stack_push
    alloc_i64 read_mem_byte obj_i64_get_value
    lisp_assert_type "read-mem-byte" i64_obj_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "write_mem_byte_instruction" {
    lisp_value_stack_push 0
    write_mem_byte bi@ { obj_i64_get_value }
    assert "write-mem-byte args are i64" and bi@ { = i64_obj_type_id obj_get_type_id } 2dup
    swap lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "bitwise_ior_instruction" {
    lisp_value_stack_push
    alloc_i64 bit_or bi@ { obj_i64_get_value }
    assert "bitwise-ior args are i64" and bi@ { = i64_obj_type_id obj_get_type_id } 2dup
    swap lisp_value_stack_pop lisp_value_stack_pop
} ;

register_lisp_instruction "string_length_instruction" {
    lisp_value_stack_push
    alloc_i64 obj_string_get_size
    assert "string-length arg is string" = string_obj_type_id obj_get_type_id dup
    lisp_value_stack_pop
} ;

register_lisp_instruction "string_get_byte_instruction" {
    lisp_value_stack_push
    alloc_i64 read_mem_byte + bi* { obj_string_get_buffer } { obj_i64_get_value } 2dup
    2drop
    assert "string-get-byte: in range" lazy_and { > 2dup } <= 0 over 
    bi* { obj_string_get_size } { obj_i64_get_value } 2dup
    # <string obj> <i64 obj>
    swap lisp_value_stack_pop lisp_value_stack_pop
    assert "string-get-byte second arg is i64" = i64_obj_type_id obj_get_type_id lisp_value_stack_peek 1
    assert "string-get-byte first arg is string" = string_obj_type_id obj_get_type_id lisp_value_stack_peek 0
} ;


constant "lisp_plus_symbol" get_or_create_symbol "+" ;
symbol_bind lisp_plus_symbol alloc_builtin_func "+" 2 obj_i64_add_instruction ;
constant "lisp_minus_symbol" get_or_create_symbol "-" ;
symbol_bind lisp_minus_symbol alloc_builtin_func "-" 2 obj_i64_sub_instruction ;
constant "lisp_mul_symbol" get_or_create_symbol "*" ;
symbol_bind lisp_mul_symbol alloc_builtin_func "*" 2 obj_i64_mul_instruction ;
constant "lisp_div_symbol" get_or_create_symbol "/" ;
symbol_bind lisp_div_symbol alloc_builtin_func "/" 2 obj_i64_div_instruction ;

constant "lisp_not_symbol" get_or_create_symbol "not" ;
constant "lisp_equal_symbol" get_or_create_symbol "equal?" ;
constant "lisp_gt_symbol" get_or_create_symbol ">" ;
constant "lisp_gte_symbol" get_or_create_symbol ">=" ;
constant "lisp_lt_symbol" get_or_create_symbol "<" ;
constant "lisp_lte_symbol" get_or_create_symbol "<=" ;

constant "lisp_define_symbol" get_or_create_symbol "define" ;
constant "lisp_lambda_symbol" get_or_create_symbol "lambda" ;
constant "lisp_let_symbol" get_or_create_symbol "let" ;
constant "lisp_if_symbol" get_or_create_symbol "if" ;
constant "lisp_begin_symbol" get_or_create_symbol "begin" ;

constant "lisp_quote_symbol" get_or_create_symbol "quote" ;
constant "lisp_eval_symbol" get_or_create_symbol "eval" ;
constant "lisp_car_symbol" get_or_create_symbol "car" ;
constant "lisp_cdr_symbol" get_or_create_symbol "cdr" ;
constant "lisp_cons_symbol" get_or_create_symbol "cons" ;
symbol_bind lisp_cons_symbol alloc_builtin_func "cons" 2 cons_instruction ;

constant "lisp_nil_symbol" get_or_create_symbol "nil" ;
symbol_bind lisp_nil_symbol 0 ;

constant "lisp_list_q_symbol" get_or_create_symbol "list?" ;
symbol_bind lisp_list_q_symbol alloc_builtin_func "list?" 1 list_q_instruction
constant "lisp_length_symbol" get_or_create_symbol "length" ;
symbol_bind lisp_length_symbol alloc_builtin_func "length" 1 {
    lisp_value_stack_push
    alloc_i64 obj_list_length
    lisp_value_stack_pop
} ;

constant "lisp_list_symbol" get_or_create_symbol "list" ;

constant "lisp_read_syntax_symbol" get_or_create_symbol "read-syntax" ;
constant "lisp_print_symbol" get_or_create_symbol "print" ;
constant "lisp_print_string_symbol" get_or_create_symbol "print-string" ;

constant "lisp_cell_symbol" get_or_create_symbol "cell" ;
constant "lisp_cell_get_symbol" get_or_create_symbol "cell-get" ;
constant "lisp_cell_set_symbol" get_or_create_symbol "cell-set" ;

constant "lisp_the_s2_dictionaty_ptr_symbol" get_or_create_symbol "the-s2-dictionary-ptr" ;
symbol_bind lisp_the_s2_dictionaty_ptr_symbol alloc_i64 the_dictionary ;
constant "lisp_s2_return_stack_ptr_symbol" get_or_create_symbol "s2-return-stack-ptr" ;
symbol_bind lisp_s2_return_stack_ptr_symbol alloc_i64 return_stack_bottom ;
constant "lisp_exit_symbol" get_or_create_symbol "exit" ;
symbol_bind lisp_exit_symbol alloc_builtin_func "exit" 1 exit_instruction ;
constant "lisp_syscall_symbol" get_or_create_symbol "syscall" ;
constant "lisp_native_call_symbol" get_or_create_symbol "native-call" ;

constant "lisp_read_mem_i64_symbol" get_or_create_symbol "read-mem-i64" ;
constant "lisp_write_mem_i64_symbol" get_or_create_symbol "write-mem-i64" ;
constant "lisp_read_mem_byte_symbol" get_or_create_symbol "read-mem-byte" ;
constant "lisp_write_mem_byte_symbol" get_or_create_symbol "write-mem-byte" ;

constant "lisp_bitwise_ior_symbol" get_or_create_symbol "bitwise-ior" ;

constant "lisp_string_length_symbol" get_or_create_symbol "string-length" ;
constant "lisp_string_get_byte_symbol" get_or_create_symbol "string-get-byte" ;
constant "lisp_string_from_native_buffer_symbol" get_or_create_symbol "string-from-native-buffer" ;
symbol_bind lisp_string_from_native_buffer_symbol alloc_builtin_func "string-from-native-buffer" 2 {
    lisp_value_stack_push alloc_string_from_buffer
    # <length> <buffer>
    obj_i64_get_value
    assert "length is i64" lisp_obj_is_i64 dup lisp_value_stack_pop
    obj_i64_get_value
    assert "native-buffer is i64" lisp_obj_is_i64 dup lisp_value_stack_pop
} ;

constant "lisp_print_stack_trace_symbol" get_or_create_symbol "print-stack-trace" ;
symbol_bind lisp_print_stack_trace_symbol alloc_builtin_func "print-stack-trace" 0 {
    lisp_value_stack_push 0
    #lisp_print_stack_trace
} ;

def "obj_is_symbol" { drop swap lazy_and { = symbol_obj_type_id obj_get_type_id dup } not = 0 dup } ;
se_check_last_defined_function ;

def "obj_is_builtin" { drop swap lazy_and { = builtin_func_obj_type_id obj_get_type_id dup } not = 0 dup } ;
se_check_last_defined_function ;

constant "code_buffer_stack" array_list_new ;

def "code_buffer_stack_peek" { array_list_get_last code_buffer_stack } ;
se_check_last_defined_function ;
def "code_buffer_stack_push_new" { array_list_append code_buffer_stack code_buffer_new } ;
se_check_last_defined_function ;
def "code_buffer_stack_pop" { code_buffer_make_function_and_destroy array_list_pop_last code_buffer_stack } ;
se_check_last_defined_function ;

def "lisp_compile_emit_literal" { 
    code_buffer_emit_literal code_buffer_stack_peek
} ;
se_check_last_defined_function ;

def "lisp_compile_emit_call" { 
    code_buffer_emit_call code_buffer_stack_peek
} ;
se_check_last_defined_function ;

constant "stack_bindings" array_list_new ;

def "stack_bindings_push_unnamed" {
    array_list_append stack_bindings 0
} ;

# <symbol> ->
def "stack_bindings_bind_top" {
    array_list_set stack_bindings + -1 array_list_get_size stack_bindings 
} ;
se_check_last_defined_function ;

# <num items to drop> ->
def "stack_bindings_drop_n" {
    array_list_set_size stack_bindings - array_list_get_size stack_bindings
} ;
se_check_last_defined_function ;

# <num items to drop> ->
def "stack_bindings_drop_swap_n_times" {
    array_list_set_size stack_bindings - array_list_get_size stack_bindings 
    array_list_set stack_bindings + -1 - array_list_get_size stack_bindings dip { array_list_get_last stack_bindings } dup
} ;
se_check_last_defined_function ;

# <symbol> -> <found bool> <stack index>
def "stack_bindings_find" {
    if { = -1 dup } {
        false
    } {
        true + -1 - array_list_get_size stack_bindings 
    }
    drop swap
    while { lazy_and { not = array_list_get stack_bindings 2dup } <= 0 dup } { + -1 }
    # <index> <symbol>
    + -1 array_list_get_size stack_bindings
} ;
se_check_last_defined_function ;

def "lisp_compile_list"
    when { = lisp_let_symbol obj_pair_car dup } then {
        drop
        stack_bindings_drop_swap_n_times obj_list_length obj_pair_car dup
        lisp_compile_emit_call { lisp_value_drop_swap_n_times }
        lisp_compile_emit_literal obj_list_length obj_pair_car dup
        lisp_compile_expression obj_pair_car obj_pair_cdr dup # compile 'let' body
        keep {
            drop while { not = 0 dup } {
                obj_pair_cdr
                stack_bindings_bind_top obj_pair_car obj_pair_car dup # bind stack slot to symbol
                lisp_compile_expression obj_pair_car obj_pair_cdr obj_pair_car dup # compile binding body
            }
            obj_pair_car
        }
        assert "let has bindings list" obj_is_list obj_pair_car dup
        assert "let has 2 args" = 2 obj_list_length dup
        obj_pair_cdr
    } otherwise
    when { obj_is_symbol obj_pair_car dup } then {
        stack_bindings_push_unnamed
        stack_bindings_drop_n obj_builtin_get_arg_count symbol_get_binding obj_pair_car
        lisp_compile_emit_call obj_builtin_get_instruction symbol_get_binding obj_pair_car dup
        keep {
            drop while { not = 0 dup } {
                obj_pair_cdr
                lisp_compile_expression obj_pair_car dup
            } obj_pair_cdr
        }
        assert "arg count" = bi
            { + 1 obj_builtin_get_arg_count symbol_get_binding obj_pair_car }
            { obj_list_length }
        dup
        assert "binding is a builtin" obj_is_builtin symbol_get_binding obj_pair_car dup
        assert "symbol has binding" symbol_has_binding obj_pair_car dup
    } otherwise
    {
        drop
        assert "dead code" false
        print_obj
    }
;

def "lisp_compile_expression_switch" 
    when { obj_is_list dup } then {
        lisp_compile_list
    } otherwise
    when { obj_is_symbol dup } then {
        if { } {
            stack_bindings_push_unnamed
            lisp_compile_emit_call { lisp_value_stack_peek_n_and_push }
            lisp_compile_emit_literal 
            drop swap
        } {
            stack_bindings_push_unnamed
            lisp_compile_emit_call { lisp_value_stack_push }
            lisp_compile_emit_literal symbol_get_binding
            assert "symbol has binding" symbol_has_binding dup
            drop
        }
        stack_bindings_find dup
    } otherwise
    {
        stack_bindings_push_unnamed
        lisp_compile_emit_call { lisp_value_stack_push }
        lisp_compile_emit_literal
        lisp_code_literal_list_add dup
    }
;

def "lisp_compile_expression" {
    lisp_compile_expression_switch
    assert "obj type id is OK" and bi { <= 0 } { >= 7 } obj_get_type_id dup
} ;

def "define_instruction_func" { call define_instruction } ;
se_check_last_defined_function ;
def "call_instruction_func" { call call_instruction } ;
# se_check_last_defined_function ;
def "make_cell_instruction_func" { call make_cell_instruction } ;
se_check_last_defined_function ;

def "read_mem_i64_instruction_func" { call read_mem_i64_instruction } ;
se_check_last_defined_function ;
def "read_mem_byte_instruction_func" { call read_mem_byte_instruction } ;
se_check_last_defined_function ;
def "write_mem_i64_instruction_func" { call write_mem_i64_instruction } ;
se_check_last_defined_function ;
def "write_mem_byte_instruction_func" { call write_mem_byte_instruction } ;
se_check_last_defined_function ;
def "bitwise_ior_instruction_func" { call bitwise_ior_instruction } ;
se_check_last_defined_function ;
def "print_string_instruction_func" { call print_string_instruction } ;
se_check_last_defined_function ;

se_check_function_by_name "symbol_bind" ;
se_check_function_by_name "obj_is_symbol" ;
#se_enable ;
se_check_function_by_name "lisp_compile_expression" ;
se_check_function_by_name "lisp_gc_push_roots_to_stack" ;
se_check_function_by_name "read_next_expression" ;
se_check_function_by_name "lisp_program_stack_print" ;
se_check_function_by_name "lisp_call_stack_print" ;
se_check_function_by_name "print_obj" ;
se_check_function_by_name "not_instruction_f" ;
se_check_function_by_name "lisp_gc_sweep" ;
se_check_function_by_name "lisp_assert_type" ;


#while { true } { print_newline token_print read_next_token } ;
#while { true } { print_newline print_obj lisp_value_stack_pop read_next_expression } ;
while { true } { 
    print_newline print_obj lisp_value_stack_pop
    assert "single value on value stack" = 1 array_list_get_size lisp_value_stack
    call code_buffer_stack_pop
    stack_bindings_drop_n 1
    assert "single value on compile stack" = 1 array_list_get_size stack_bindings
    lisp_compile_expression lisp_value_stack_pop read_next_expression
    code_buffer_stack_push_new
} ;
