# import buffered_stdin.2s
# import byte_vector.2s
# import array_list.2s
# import stack_effect.2s
# import switch_stmt.2s
# import lib.2s

#se_enable ;

def "string_first_char" {
    byte_vector_get dip { 0 }
} ;
se_check_last_defined_function ;

constant "open_paren_char" string_first_char "(" ;
constant "close_paren_char" string_first_char ")" ;
constant "space_char" string_first_char " " ;
constant "t_char" string_first_char "t" ;
constant "n_char" string_first_char "n" ;
constant "x_char" string_first_char "x" ;
constant "tab_char" string_first_char "\t" ;
constant "hash_char" string_first_char "#" ;
constant "newline_char" string_first_char "\n" ;
constant "semicolon_char" string_first_char ";" ;
constant "double_quote_char" 34 ;
constant "single_quote_char" 39 ;
constant "backquote_char" string_first_char "`" ;
constant "backslash_char" 92 ;

# <char> -> <bool>
def "is_whitespace_char" {
    drop swap
    lazy_or { lazy_or { = space_char dup } = tab_char dup } = newline_char dup
} ;

def "is_paren_char" {
    or bi { = open_paren_char } { = close_paren_char }
} ;

def "skip_whitespace_and_comments" {
    while { lazy_or { = semicolon_char scanner_peek } is_whitespace_char scanner_peek } {
        if { = semicolon_char scanner_peek } {
            while { not = newline_char scanner_peek } { # skip line comment
                scanner_advance
            }
        } {
            scanner_advance # skip whitespace
        }
    }
} ;

constant "token_open_paren_type"            0 ;
constant "token_close_paren_type"           1 ;
constant "token_symbol_or_i64_literal_type" 2 ;
constant "token_string_literal_type"        3 ;
constant "token_char_literal_type"          4 ;
constant "token_backquote_type"             5 ;

# <expr type id> <value> -> <token>
def "token_create" {
    keep { write_mem_i64 + 8 }
    keep { write_mem_i64 }
    malloc * 2 8
} ;
 
# <expr> -> <token type id>
def "token_get_type_id" {
    read_mem_i64
} ;

# <expr> -> <value>
def "token_get_value" {
    read_mem_i64 + 8
} ;

def "token_print_switch"
    when { = token_open_paren_type dup } then { print_string "open paren" 2drop } otherwise
    when { = token_close_paren_type dup } then { print_string "close paren" 2drop } otherwise
    when { = token_symbol_or_i64_literal_type dup } then { print_string "'" print_string token_get_value print_string "symbol or i64 literal: '" drop } otherwise
    when { = token_char_literal_type dup } then { print_string "'" print_string token_get_value print_string "char literal: '" drop } otherwise
    when { = token_string_literal_type dup } then {
        print_string "'" byte_vector_destroy print_string dup decode_string_literal print_string "decoded: '"
        print_string "', " print_string dup token_get_value
        print_string "string literal: '" drop } otherwise
    { assert "bad token type" false 2drop . dup }
;

# <token> ->
def "token_print" {
    token_print_switch
    token_get_type_id dup
} ;

def "token_destroy_switch"
    when { = token_open_paren_type dup } then { free drop } otherwise
    when { = token_close_paren_type dup } then { free drop } otherwise
    when { = token_symbol_or_i64_literal_type dup } then {
        bi { free } { byte_vector_destroy token_get_value } drop
    } otherwise
    when { = token_char_literal_type dup } then {
        bi { free } { byte_vector_destroy token_get_value } drop
    } otherwise
    when { = token_string_literal_type dup } then {
        bi { free } { byte_vector_destroy token_get_value } drop
    } otherwise
    { assert "bad token type" false 2drop . dup }
;

# <token> ->
def "token_destroy" {
    token_destroy_switch
    token_get_type_id dup
} ;

def "scanner_peek" {
    buffered_stdin_peek_byte
} ;

def "scanner_advance" {
    drop buffered_stdin_read_byte
} ;

def "read_next_token_symbol_or_number" {
    token_create token_symbol_or_i64_literal_type
    while { lazy_and { not is_paren_char scanner_peek } not is_whitespace_char scanner_peek } {
        scanner_advance
        keep { byte_vector_append dip { scanner_peek } } 
    }
    byte_vector_new
} ;

def "is_double_quote_or_newline" { or bi { = double_quote_char } { = newline_char } } ;

# -> <token>
def "read_next_token_double_quote" {
    token_create token_string_literal_type
    scanner_advance
    assert "no newline in string literals" not = newline_char scanner_peek
    while { not is_double_quote_or_newline scanner_peek } {
        scanner_advance
        if { = backslash_char scanner_peek } {
            keep { byte_vector_append dip { scanner_peek } } 
            scanner_advance
        } { }
        keep { byte_vector_append dip { scanner_peek } } 
    }
    scanner_advance
    byte_vector_new
} ;

# -> <token> # scanner on the char's position
def "read_next_token_switch"
    when { = single_quote_char scanner_peek } then {
        token_create token_backquote_type 0
        scanner_advance
    } otherwise
    when { = open_paren_char scanner_peek } then {
        token_create token_open_paren_type 0
        scanner_advance
    } otherwise
    when { = close_paren_char scanner_peek } then {
        token_create token_close_paren_type 0
        scanner_advance
    } otherwise
    when { = double_quote_char scanner_peek } then { read_next_token_double_quote } otherwise
    { read_next_token_symbol_or_number }
;

# -> <token>
def "read_next_token" {
    read_next_token_switch
    skip_whitespace_and_comments
} ;
se_check_last_defined_function ;

# <char> -> <char>
def "decode_escaped_char" 
    when { = string_first_char "t" dup } then { tab_char drop } otherwise
    when { = string_first_char "n" dup } then { newline_char drop } otherwise
    when { = double_quote_char dup } then { double_quote_char drop } otherwise
    when { = backslash_char dup } then { backslash_char drop } otherwise
    { 0 assert "no bad chars" false print_newline . }
;
# <string> -> <string>
def "decode_string_literal" {
    dip { 2drop }
    while { swap dip { > byte_vector_get_size 2dup } } {
        keep { byte_vector_append }
        dip {
            2dip { + 1 }
            if { = backslash_char dup } {
                decode_escaped_char byte_vector_get 2dup
                dip { + 1 }
                drop
            } { }
            byte_vector_get 2dup
        }
    }
    # <new string> <original string> <index>
    byte_vector_new dip { 0 }
} ;
se_check_last_defined_function ;

# Lisp objects
#
# Every object has a 8-byte header
# Object header structure: [type_id: i64][gc_marked_flag (0 or 1) i64]
#
# Types
#   symbol:
#       type_id: 0
#       structure: [length: i64][string_buffer: variable]
#   i64:
#       type_id: 1
#       structure: [value: i64]
#   pair:
#       type_id: 2
#       structure: [car: pointer][cdr: pointer]
#   nil:
#       null pointer
#
#   Symbols
#       Symbols are interned strings and are not freed by GC

constant "symbol_obj_type_id"   0 ;
constant "i64_obj_type_id"      1 ;
constant "pair_obj_type_id"     2 ;
constant "lambda_obj_type_id"   3 ;
constant "env_obj_type_id"      4 ;
constant "bool_obj_type_id"     5 ;
constant "cell_obj_type_id"     6 ;
constant "string_obj_type_id"   7 ;
constant "builtin_func_obj_type_id"   8 ;

constant "obj_header_size" 16 ;

# <obj ptr> <type_id> ->
def "obj_set_type_id" {
    write_mem_i64
} ;

# <obj ptr> ->
def "obj_get_type_id" {
    read_mem_i64
} ;

# <obj ptr> <type_id> ->
def "obj_set_gc_marked_flag" {
    write_mem_i64 + 8
} ;

# <obj ptr> ->
def "obj_get_gc_marked_flag" {
    read_mem_i64 + 8
} ;

# <string> -> <symbol>
def "alloc_symbol" {
    keep {
        memcopy swap dip { bi { byte_vector_get_array } { byte_vector_get_size } }
        + 24
        write_mem_i64 dip { byte_vector_get_size } 2dup
        + obj_header_size
    }
    keep { write_mem_i64 swap 0 + 16 + obj_header_size }
    keep { write_mem_i64 swap false + 8 + obj_header_size }
    obj_set_type_id swap symbol_obj_type_id dup
    # <symbol ptr> <string>
    malloc + * 8 3 + obj_header_size byte_vector_get_size dup
} ;
se_check_last_defined_function ;

def "symbol_get_size" {
    read_mem_i64 + obj_header_size
} ;

def "symbol_has_binding" {
    read_mem_i64 + 8 + obj_header_size
} ;

# <symbol> <bool> -> 
def "symbol_set_binding_flag" {
    write_mem_i64 + 8 + obj_header_size
} ;

def "symbol_get_binding" {
    read_mem_i64 + 16 + obj_header_size
} ;

# <symbol> <value> -> 
def "symbol_set_binding" {
    write_mem_i64 + 16 + obj_header_size
} ;

def "symbol_get_buffer" {
    + 24 + obj_header_size
} ;

# <symbol> <value> -> 
def "symbol_bind" {
    symbol_set_binding
    keep { symbol_set_binding_flag swap true }
    if { symbol_has_binding dup } {
        exit 1
        print_newline
        print_obj symbol_get_binding dup
        print_string "is already bound to "
        print_obj dup
        print_string "symbol "
    } { }
} ;

# <symbol> -> 
def "symbol_unbind" {
    symbol_set_binding_flag swap false
} ;

# <buffer> <size>
def "print_buffer" {
    assert "buffer is fully written" =
    dip {
        panic_on_syscall_error
        syscall 1 1 2dip { 1 2 3 }
    }
    over
} ;

constant "symbol_list" array_list_new ;

# <symbol> <string> -> <bool>
def "symbol_name_equal" {
    if { = bi* { symbol_get_size } { byte_vector_get_size } 2dup } {
        = 0 memcmp dip { bi* { symbol_get_buffer } { byte_vector_get_array } } symbol_get_size dup
    } {
        false 2drop
    }
} ;
se_check_last_defined_function ;

# <string> -> <symbol>
def "get_or_create_symbol" {
    if { = array_list_get_size symbol_list dup } {
        array_list_append symbol_list dup alloc_symbol drop
    } {
        array_list_get symbol_list dip { drop }
    }
    while { lazy_and { not symbol_name_equal array_list_get symbol_list 2dup } > array_list_get_size symbol_list dup } {
        + 1
    }
    0
} ;
se_check_last_defined_function ;

# <number> -> <obj>
def "alloc_i64" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap i64_obj_type_id }
    malloc + 8 obj_header_size
    lisp_run_gc
} ;

# <obj> -> <value>
def "obj_i64_get_value" {
    read_mem_i64 + obj_header_size
} ;

# <car obj> <cdr obj> -> <pair obj>
def "alloc_pair" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + 8 + obj_header_size }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap pair_obj_type_id }
    malloc + 16 obj_header_size
    lisp_run_gc
} ;

# <obj> -> <value>
def "obj_pair_car" {
    read_mem_i64 + obj_header_size
    assert "car: obj is pair" = pair_obj_type_id obj_get_type_id dup
    assert "car: obj is not nil" not = 0 dup
} ;

# <obj> -> <value>
def "obj_pair_cdr" {
    read_mem_i64 + 8 + obj_header_size
    assert "cdr: obj is pair" = pair_obj_type_id obj_get_type_id dup
    assert "cdr: obj is not nil" not = 0 dup
} ;

def "obj_pair_invalidate" {
    write_mem_i64 swap -1 + 8 + obj_header_size
    write_mem_i64 swap -1 + obj_header_size dup
} ;
se_check_last_defined_function ;

# <obj> -> <bool>
def "obj_is_pair" {
    if { = 0 dup } {
        false drop
    } {
        = pair_obj_type_id obj_get_type_id
    }
} ;

# <obj> -> <bool>
def "obj_is_list" {
    = 0 while { obj_is_pair dup } { obj_pair_cdr }
} ;

def "obj_list_length" {
    drop
    while { obj_is_pair dup } {
        dip { + 1 }
        obj_pair_cdr
    }
    dip { 0 }
    assert "obj is list" obj_is_list dup
} ;

def "print_list" {
    print_string ")"
    drop
    while { not = 0 dup } {
        if { not = 0 dup } { print_string " " } { }
        obj_pair_cdr
        print_obj obj_pair_car dup
    }
    print_string "("
    assert "is list" obj_is_list dup
} ;

# <local env stack> <arg list> <body> -> <lambda>
def "alloc_lambda" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + 16 + obj_header_size }
    keep { write_mem_i64 + 8 + obj_header_size }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap lambda_obj_type_id }
    malloc + 24 obj_header_size
    lisp_run_gc
} ;

def "obj_lambda_get_local_env" { read_mem_i64 + obj_header_size } ;
def "obj_lambda_get_arg_list" { read_mem_i64 + 8 + obj_header_size } ;
def "obj_lambda_get_body" { read_mem_i64 + 16 + obj_header_size } ;

def "obj_lambda_invalidate" {
    write_mem_i64 swap -1 + 16 + obj_header_size
    write_mem_i64 swap -1 + 8 + obj_header_size dup
    write_mem_i64 swap -1 + obj_header_size dup
} ;
se_check_last_defined_function ;

# <bindings list> ->
def "alloc_env" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + obj_header_size } # bindings list is set here
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap env_obj_type_id }
    malloc + 8 obj_header_size
    lisp_run_gc
} ;

def "obj_env_get_bindings" { read_mem_i64 + obj_header_size } ;

# <env> <symbol> <value> -> 
def "obj_env_add_binding" {
    array_list_append
    keep { array_list_append }
    obj_env_get_bindings
    dip { swap }
} ;
se_check_last_defined_function ;

def "obj_env_invalidate" {
    write_mem_i64 swap -1 + obj_header_size
} ;
se_check_last_defined_function ;

def "alloc_bool" {
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap bool_obj_type_id }
    malloc obj_header_size
} ;

constant "obj_bool_true" alloc_bool ;
constant "obj_bool_false" alloc_bool ;

constant "lisp_true_symbol" get_or_create_symbol "true" ;
constant "lisp_false_symbol" get_or_create_symbol "false" ;

symbol_bind lisp_true_symbol obj_bool_true ;
symbol_bind lisp_false_symbol obj_bool_false ;

# <obj> -> <cell>
def "alloc_cell" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap cell_obj_type_id }
    malloc + 8 obj_header_size
    lisp_run_gc
} ;

def "obj_cell_get" {
    read_mem_i64 + obj_header_size
} ;

def "obj_cell_set" {
    write_mem_i64 + obj_header_size
} ;

def "obj_cell_invalidate" {
    write_mem_i64 swap -1 + obj_header_size
} ;

# <string> -> <obj>
def "alloc_string" {
    keep {
        memcopy swap dip { bi { byte_vector_get_array } { byte_vector_get_size } }
        + 8
        write_mem_i64 dip { byte_vector_get_size } 2dup
        + obj_header_size
    }
    keep { obj_set_gc_marked_flag swap false }
    keep { obj_set_type_id swap string_obj_type_id }
    # <string obj ptr> <string>
    malloc + 8 + obj_header_size byte_vector_get_size dup
} ;

# <string obj> -> <i64>
def "obj_string_get_size" {
    read_mem_i64 + obj_header_size
} ;

# <string obj> -> <buffer>
def "obj_string_get_buffer" {
    + 8 + obj_header_size
} ;

# <string obj> <string obj> -> <bool>
def "obj_string_eq" {
    dip { 2drop }
    lazy_and {
        = 0
        memcmp 
        dip { bi@ { obj_string_get_buffer } }
        obj_string_get_size dup 
        2dup
    } = bi@ { obj_string_get_size } 2dup
    assert "string-equals args are strings" and bi@ { = string_obj_type_id obj_get_type_id } 2dup
} ;

# <name> <arg count> <instruction>
def "alloc_builtin_func" {
    keep { lisp_gc_ref_list_append }
    keep { write_mem_i64 + 16 + obj_header_size }
    keep { write_mem_i64 + 8 + obj_header_size }
    keep { write_mem_i64 + obj_header_size }
    keep { obj_set_gc_marked_flag swap 0 }
    keep { obj_set_type_id swap builtin_func_obj_type_id }
    malloc + 24 obj_header_size
    lisp_run_gc
} ;

# <obj> -> <value>
def "obj_builtin_get_name" {
    read_mem_i64 + obj_header_size
} ;

# <obj> -> <value>
def "obj_builtin_get_arg_count" {
    read_mem_i64 + 8 + obj_header_size
} ;

# <obj> -> <value>
def "obj_builtin_get_instruction" {
    read_mem_i64 + 16 + obj_header_size
} ;

def "print_obj_switch"
    when { = obj_bool_true dup } then { print_string "true" drop } otherwise
    when { = obj_bool_false dup } then { print_string "false" drop } otherwise
    when { obj_is_list dup } then { print_list } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then { print_buffer bi { symbol_get_buffer } { symbol_get_size } print_string "'" } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then { . obj_i64_get_value } otherwise
    when { obj_is_list dup } then { print_list } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        print_obj obj_pair_cdr
        print_string " . "
        print_obj obj_pair_car dup
        print_string "("
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        print_obj obj_lambda_get_body
        print_string " "
        print_obj obj_lambda_get_arg_list dup
        print_string " "
        print_obj obj_lambda_get_local_env dup
        print_string "(lambda "
    } otherwise
    when { = env_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        2drop
        while { < 0 dup } {
            if { = 0 dup } {
            } {
                print_string " "
            }
            print_string ")"
            print_obj
            array_list_get swap 2dup
            + -1
            print_string " . "
            print_obj
            array_list_get swap 2dup
            + -1
            print_string "("
        }
        array_list_get_size dup
        obj_env_get_bindings
        print_string "(env "
    } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        print_string ")"
        print_obj obj_cell_get
        print_string "(cell "
    } otherwise
    when { = string_obj_type_id obj_get_type_id dup } then {
        write_byte_to_stdout double_quote_char
        print_buffer bi { obj_string_get_buffer } { obj_string_get_size }
        write_byte_to_stdout double_quote_char
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then {
        print_string ">"
        print_string obj_builtin_get_name
        print_string "<builtin function "
    } otherwise
    { assert "OK" false print_newline . obj_get_type_id print_string "print_obj_switch: unsuppoted obj type: " }
;

def "print_obj" {
    if { = 0 dup } {
        print_string "nil" drop
    } {
        print_obj_switch
    }
} ;
se_check_last_defined_function ;

# <obj> ->
def "destroy_obj"
    when { = bool_obj_type_id obj_get_type_id dup } then { drop } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then { drop } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then {
        free
    } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        free
        obj_pair_invalidate dup
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then {
        free
        obj_lambda_invalidate dup
    } otherwise
    when { = env_obj_type_id obj_get_type_id dup } then {
        free
        obj_env_invalidate dup
        array_list_destroy obj_env_get_bindings dup
    } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        free
        obj_cell_invalidate dup
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then { drop } otherwise
    { assert "suppoted obj type" false print_newline . obj_get_type_id }
;
se_check_last_defined_function ;


# <obj> <obj> -> <bool>
def "obj_equal_switch"
    when { = bool_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then {
        = bi@ { obj_i64_get_value }
    } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        dip { 2drop }
        lazy_and { obj_equal bi@ { obj_pair_cdr } 2dup }
        obj_equal bi@ { obj_pair_car } 2dup
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = env_obj_type_id obj_get_type_id dup } then { = } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        obj_equal bi@ { obj_cell_get }
    } otherwise
    when { = string_obj_type_id obj_get_type_id dup } then {
        obj_string_eq
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then { = } otherwise
    { false assert "suppoted obj type" false drop print_newline . obj_get_type_id }
 ;

# <obj> <obj> -> <bool>
def "obj_equal" {
    if { = 2dup } {
        true 2drop
    } {
        if { lazy_and { = bi@ { obj_get_type_id } 2dup } and bi@ { not = 0 } 2dup } {
            obj_equal_switch
        } {
            false 2drop
        }
    }
} ;
se_check_last_defined_function ;

constant "current_token_ptr" malloc 8 ;

def "token_scanner_advance" {
    write_mem_i64 current_token_ptr 0
} ;
def "token_scanner_peek" {
    read_mem_i64 current_token_ptr
    if { = read_mem_i64 current_token_ptr 0 } {
        write_mem_i64 current_token_ptr read_next_token
    } { }
} ;


# <char*> <size> -> <bool> <number>
def "parse_i64_non_empty" {
    2drop # <char* end> <char*> <bool> <number>
    if { = 45 read_mem_byte over } {
        # negative
        if { = 2dup } {
            2dip { false drop } # single "-" case
        } {
            while { lazy_and { rot 2dip { dup } } > 2dup } {
                dip {
                    + 1 # <char*> <bool> <number>
                    if { and bi { <= 48 } { > 58 } read_mem_byte dup } {
                        keep {
                            and
                            dip { checked_add * -1 + -48 read_mem_byte }
                            swap
                        } # <char*> <bool> <number>
                        dip { checked_mul 10 drop }
                    } {
                        dip { false drop }
                    }
                }
            }
        }
        dip { + 1 }
    } {
        # positive
        while { lazy_and { rot 2dip { dup } } > 2dup } {
            dip {
                + 1 # <char*> <bool> <number>
                if { and bi { <= 48 } { > 58 } read_mem_byte dup } {
                    keep {
                        and
                        dip { checked_add + -48 read_mem_byte }
                        swap
                    } # <char*> <bool> <number>
                    dip { checked_mul 10 drop }
                } {
                    dip { false drop }
                }
            }
        }
    }
    # <char* end> <char*> <bool> <number>
    swap keep { + }
    2dip { true 0 }
} ;

# <char*> <size> -> <bool> <number>
def "parse_i64" {
    if { < 0 over } {
        parse_i64_non_empty
    } {
        false 0 2drop
    }
} ;

# <buffer> <number> ->
def "render_i64" {
    2drop
    if { > 0 over } {
        # negative
        write_mem_byte swap 45 dup
        while { not = 0 over } {
            + -1 dip { / swap 10 }
            2keep { 
                write_mem_byte dip { + 48 * -1 % swap 10 }
            }
        }
        + -1 dip { / swap 10 }
        2keep { 
            write_mem_byte dip { + 48 * -1 % swap 10 }
        }
    } {
        # positive
        while { not = 0 over } {
            + -1 dip { / swap 10 }
            2keep { 
                write_mem_byte dip { + 48 % swap 10 }
            }
        }
        + -1 dip { / swap 10 }
        2keep { 
            write_mem_byte dip { + 48 % swap 10 }
        }
    }
    # <buffer end> <number>
    + dip { + -1 i64_text_length dup }
} ;

# <number> -> <length>
def "i64_text_length" {
    drop swap
    while { not = 0 over }  {
        + 1 dip { / swap 10 }
    }
        + 1 dip { / swap 10 }
    # <length> <number>
    if { > 0 dup } { 1 } { 0 }
} ;

def "parse_i64_string" {
    parse_i64 bi { byte_vector_get_array } { byte_vector_get_size }
} ;

# <byte> -> <bool>
def "is_hex_digit" {
    drop r>
    or
        and > 103 r@ <= 97 r@
        and > 58 r@ <= 48 r@
    >r
} ;

# <byte> -> <number>
def "parse_hex_digit" {
    if { > 58 dup } {
        + -48
    } {
        + -87
    }
} ;

# <char*> <size> -> <bool> <number>
def "parse_hex_i64" {
    if { lazy_and { <= 3 over } >= 18 over } {
        if { lazy_and { = hash_char read_mem_byte dup } = x_char read_mem_byte + 1 dup } {
            2drop
            while { lazy_and { rot 2dip { dup } } > 2dup } {
                dip {
                    + 1
                    keep {
                        if { is_hex_digit read_mem_byte dup } {
                            true
                            + parse_hex_digit read_mem_byte
                            dip { * 16 }
                        } {
                            false drop
                        }
                    }
                    # <current char*> <number>
                    dip { drop }
                }
            }
            # <end char*> <current char*> <bool> <number>
            2dip { true 0 }
            swap
            + 2 # skip prefix
            keep { + }
        } {
            false 0 2drop # wrong prefix
        }
    } {
        false 0 2drop # wrong size
    }
} ;


def "parse_hex_i64_string" {
    parse_hex_i64 bi { byte_vector_get_array } { byte_vector_get_size }
} ;
se_check_last_defined_function ;

constant "lisp_value_stack" array_list_new ;

def "lisp_value_stack_push" {
    array_list_append lisp_value_stack
} ;

def "lisp_value_stack_pop" {
    array_list_pop_last lisp_value_stack
} ;

def "lisp_value_stack_peek_top" {
    array_list_get_last lisp_value_stack
} ;

def "lisp_value_stack_peek" {
    array_list_peek lisp_value_stack
} ;

constant "lisp_program_stack" array_list_new ;

def "lisp_program_stack_push" {
    array_list_append lisp_program_stack
} ;

def "lisp_program_stack_pop" {
    array_list_pop_last lisp_program_stack
} ;

constant "lisp_gc_logging_enabled_pointer" malloc 8 ;
write_mem_i64 lisp_gc_logging_enabled_pointer false ;
def "lisp_gc_logging_is_enabled" { read_mem_i64 lisp_gc_logging_enabled_pointer } ;
def "lisp_gc_logging_enable" { write_mem_i64 lisp_gc_logging_enabled_pointer true } ;

constant "lisp_gc_ref_list" array_list_new ;
def "lisp_gc_ref_list_append" {
    array_list_append lisp_gc_ref_list
    if { lisp_gc_logging_is_enabled } {
        print_newline print_obj print_string "allocation: " dup
        print_newline . array_list_get_size lisp_gc_ref_list print_string "allocation: number of alive objs: "
    } { }
} ;

constant "lisp_gc_marker_stack" array_list_new ;

# <obj> ->
def "lisp_gc_marker_stack_push" {
    if { lazy_or { obj_get_gc_marked_flag dup } = 0 dup } {
        drop # do nothing, obj was marked
    } {
        array_list_append lisp_gc_marker_stack
    }
} ;

def "lisp_gc_push_roots_to_stack" {
    lisp_gc_marker_stack_push get_temp_lambda
    drop while { < 0 dup } {
        if { symbol_has_binding dup } {
            lisp_gc_marker_stack_push symbol_get_binding # push bindings
        } { drop }
        array_list_get symbol_list dup
        + -1
    } array_list_get_size symbol_list
    drop while { < 0 dup } {
        if { = call_instruction dup } {
            + -1 # skip arg count
            drop
        } {
            if { = literal_instruction } {
                lisp_gc_marker_stack_push array_list_get lisp_program_stack dup # push literal obj
                + -1
            } {
                # do nothing
            }
        }
        array_list_get lisp_program_stack dup
        + -1
    } array_list_get_size lisp_program_stack
    drop while { < 0 dup } {
        lisp_gc_marker_stack_push array_list_get lisp_value_stack dup # push value stack
        + -1
    } array_list_get_size lisp_value_stack
} ;

# <obj> ->
def "lisp_gc_mark_push_refs_switch" 
    when { = bool_obj_type_id obj_get_type_id dup } then {
        drop # do nothing
    } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then {
        if { symbol_has_binding dup } {
            lisp_gc_marker_stack_push symbol_get_binding 
        } {
            drop
        }
    } otherwise
    when { = i64_obj_type_id obj_get_type_id dup } then {
        drop
    } otherwise
    when { = pair_obj_type_id obj_get_type_id dup } then {
        lisp_gc_marker_stack_push obj_pair_cdr
        lisp_gc_marker_stack_push obj_pair_car dup
    } otherwise
    when { = env_obj_type_id obj_get_type_id dup } then {
        2drop while { < 0 dup } {
            lisp_gc_marker_stack_push array_list_get swap 2dup
            + -2
        } array_list_get_size dup
        obj_env_get_bindings
    } otherwise
    when { = lambda_obj_type_id obj_get_type_id dup } then {
        lisp_gc_marker_stack_push obj_lambda_get_body
        lisp_gc_marker_stack_push obj_lambda_get_arg_list dup
        lisp_gc_marker_stack_push obj_lambda_get_local_env dup
    } otherwise
    when { = cell_obj_type_id obj_get_type_id dup } then {
        lisp_gc_marker_stack_push obj_cell_get
    } otherwise
    when { = string_obj_type_id obj_get_type_id dup } then {
        drop
    } otherwise
    when { = builtin_func_obj_type_id obj_get_type_id dup } then {
        drop
    } otherwise
    { exit 1 print_newline . obj_get_type_id print_string "gc mark: bad object, obj type:" }
;
se_check_last_defined_function ;

def "lisp_gc_mark" {
    while { not array_list_is_empty lisp_gc_marker_stack } {
        lisp_gc_mark_push_refs_switch
        obj_set_gc_marked_flag swap true dup
        array_list_pop_last lisp_gc_marker_stack
    }
    lisp_gc_push_roots_to_stack 
} ;

def "lisp_gc_sweep" {
    drop while { < 0 dup } {
        if { not obj_get_gc_marked_flag array_list_get lisp_gc_ref_list dup } {
            if { = + -1 array_list_get_size lisp_gc_ref_list dup } { # if last in ref list
                destroy_obj array_list_pop_last lisp_gc_ref_list
            } {
                array_list_set lisp_gc_ref_list dip { array_list_pop_last lisp_gc_ref_list } dup # replace destroyed obj with last from ref list 
                destroy_obj array_list_get lisp_gc_ref_list dup
            }
        } {
            obj_set_gc_marked_flag swap false array_list_get lisp_gc_ref_list dup
        }
        + -1
    } array_list_get_size lisp_gc_ref_list
    if { lisp_gc_logging_is_enabled } {
        drop while { < 0 dup } {
            if { not obj_get_gc_marked_flag dup } {
                print_newline print_obj print_string "gc: will remove "
            } { drop }
            array_list_get lisp_gc_ref_list dup
            + -1
        } array_list_get_size lisp_gc_ref_list
    } { }
} ;
se_check_last_defined_function ;

def "lisp_obj_count" { array_list_get_size lisp_gc_ref_list } ;

constant "lisp_previous_obj_count_ptr" malloc 8 ;
def "lisp_previous_obj_count" { read_mem_i64 lisp_previous_obj_count_ptr } ;
def "lisp_previous_obj_count_set" { write_mem_i64 lisp_previous_obj_count_ptr } ;

lisp_previous_obj_count_set 0 ;

def "lisp_run_gc" {
    if { < * 2 lisp_previous_obj_count lisp_obj_count } {
        lisp_previous_obj_count_set lisp_obj_count
        lisp_gc_sweep
        lisp_gc_mark
    } { }
} ;

def "read_next_expression_switch"
    when { = token_backquote_type token_get_type_id token_scanner_peek } then {
        lisp_value_stack_push drop lisp_value_stack_pop
        alloc_pair lisp_quote_symbol lisp_value_stack_peek_top
        lisp_value_stack_push drop lisp_value_stack_pop
        alloc_pair lisp_value_stack_peek_top 0
        read_next_expression
        token_scanner_advance
    } otherwise
    when { = token_open_paren_type token_get_type_id token_scanner_peek } then {
        drop
        while { < 0 dup } {
            lisp_value_stack_push
            drop lisp_value_stack_pop
            drop lisp_value_stack_pop
            alloc_pair lisp_value_stack_peek 1 lisp_value_stack_peek 0
            + -1
        }
        lisp_value_stack_push 0
        token_scanner_advance
        while { not = token_close_paren_type token_get_type_id token_scanner_peek } {
            + 1
            read_next_expression
        }
        0
        token_scanner_advance
    } otherwise
    when { = token_symbol_or_i64_literal_type token_get_type_id token_scanner_peek } then {
        token_scanner_advance
        token_destroy token_scanner_peek
        if { } {
            lisp_value_stack_push alloc_i64
        } {
            if { } {
                lisp_value_stack_push alloc_i64
            } {
                lisp_value_stack_push get_or_create_symbol token_get_value token_scanner_peek drop
            }
            parse_hex_i64_string token_get_value token_scanner_peek
            drop
        }
        parse_i64_string token_get_value token_scanner_peek
    } otherwise
    when { = token_string_literal_type token_get_type_id token_scanner_peek } then {
        token_scanner_advance
        token_destroy token_scanner_peek
        lisp_value_stack_push alloc_string token_get_value token_scanner_peek
    } otherwise
    { assert "suppoted literal type" false print_newline . token_get_type_id token_scanner_peek }
;

def "read_next_expression" {
    read_next_expression_switch
} ;

# <obj> <obj> -> <obj>
def "obj_i64_add" {
    alloc_i64 + bi@ { obj_i64_get_value }
    bi@ { assert "'add' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
} ;

constant "obj_i64_add_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    obj_i64_add lisp_value_stack_peek 1 lisp_value_stack_peek 0
} ;

constant "obj_i64_sub_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_i64 - bi@ { obj_i64_get_value }
    bi@ { assert "'sub' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

constant "obj_i64_mul_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_i64 * bi@ { obj_i64_get_value }
    bi@ { assert "'mul' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 1 lisp_value_stack_peek 0
} ;

constant "obj_i64_div_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_i64 / bi@ { obj_i64_get_value }
    bi@ { assert "'div' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

constant "obj_i64_gt_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    if { > bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { assert "'gt' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

constant "obj_i64_lt_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    if { < bi@ { obj_i64_get_value } } {
        obj_bool_true
    } {
        obj_bool_false
    }
    bi@ { assert "'lt' args are i64" = i64_obj_type_id obj_get_type_id } 2dup
    lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

constant "literal_instruction" {
    lisp_value_stack_push lisp_program_stack_pop
} ;

constant "drop_instruction" {
    drop lisp_value_stack_pop
} ;

constant "define_instruction" {
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    symbol_bind
        lisp_value_stack_peek 0 # symbol
        lisp_value_stack_peek 1 # value
    if { symbol_has_binding lisp_value_stack_peek 0 } {
        exit 1
        print_newline
        print_obj lisp_value_stack_peek 0
        print_string "symbol is already defined: "
    } { }
} ;

constant "make_lambda_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_lambda
        lisp_value_stack_peek 0 # local env
        lisp_value_stack_peek 1 # arg list
        lisp_value_stack_peek 2 # body
    assert "local env is env" = env_obj_type_id obj_get_type_id lisp_value_stack_peek 0 # local env
    assert "arg list is list" obj_is_list lisp_value_stack_peek 1 # arg list
} ;

constant "temp_lambda_ptr" malloc 8 ;

def "set_temp_lambda" {
    write_mem_i64 temp_lambda_ptr
} ;

def "get_temp_lambda" {
    read_mem_i64 temp_lambda_ptr
} ;
set_temp_lambda 0 ;

def "call_lambda" {
    # TODO: remove lisp_local_env ???
    array_list_clear lisp_local_env
    drop while { < 0 dup } {
        + -1
        symbol_unbind array_list_get lisp_local_env dup
        + -1
    } array_list_get_size lisp_local_env

    set_temp_lambda 0
    lisp_compile_expression obj_lambda_get_body get_temp_lambda

    drop while { < 0 dup } {
        symbol_bind bi { array_list_get lisp_local_env + 1 } { array_list_get lisp_local_env } dup
        + -2
    } array_list_get_size lisp_local_env

    drop while { not = 0 dup } {
        obj_pair_cdr
        lisp_local_env_add_binding
        # <symbol> <value> <arg list>
        dip { lisp_value_stack_pop } obj_pair_car dup
    } obj_lambda_get_arg_list get_temp_lambda

    lisp_local_env_set_saved_env obj_lambda_get_local_env get_temp_lambda
    if { not = 2dup } {
        exit 1
        print_newline
        print_obj get_temp_lambda
        print_string ", when calling "
        .
        print_string ", got "
        .
        print_string "wrong number of arguments: expected "
    } { 2drop }
    obj_list_length obj_lambda_get_arg_list get_temp_lambda
    set_temp_lambda lisp_value_stack_pop
    # <arg count>
    lisp_program_stack_pop
} ;

constant "call_instruction" {
    if { = lambda_obj_type_id obj_get_type_id lisp_value_stack_peek_top } {
        call_lambda
    } {
        call obj_builtin_get_instruction lisp_value_stack_pop
#        drop lisp_value_stack_pop
        if { not = 2dup } {
            exit 1
            print_newline
            print_obj lisp_value_stack_peek_top
            print_string ", when calling "
            .
            print_string ", got "
            .
            print_string "wrong number of arguments: expected "
        } { 2drop }
        # arg count
        obj_builtin_get_arg_count lisp_value_stack_peek_top 
        lisp_program_stack_pop
    }
    if { not or bi { = lambda_obj_type_id } { = builtin_func_obj_type_id } obj_get_type_id lisp_value_stack_peek_top } {
        exit 1
        print_newline
        print_obj lisp_value_stack_peek_top
        print_string "trying to call non-callable obj: "
    } { }
} ;

constant "if_instruction" {
    if { = obj_bool_true lisp_value_stack_pop } {
        lisp_value_stack_push
        drop lisp_value_stack_pop
        lisp_value_stack_pop
    } {
        drop lisp_value_stack_pop
    }
    assert "if_instruction: boolean value" = bool_obj_type_id obj_get_type_id lisp_value_stack_peek_top
} ;

constant "eval_instruction" {
    lisp_compile_expression lisp_value_stack_pop
} ;

constant "car_instruction" {
    lisp_value_stack_push obj_pair_car lisp_value_stack_pop
} ;

constant "cdr_instruction" {
    lisp_value_stack_push obj_pair_cdr lisp_value_stack_pop
} ;

constant "cons_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    drop lisp_value_stack_pop
    alloc_pair lisp_value_stack_peek 0 lisp_value_stack_peek 1
} ;

constant "read_syntax_instruction" {
    read_next_expression
} ;

constant "print_instruction" {
    lisp_value_stack_push 0
    print_obj lisp_value_stack_pop
} ;

# <char> -> <char>
def "unescape_string_char"
    when { = t_char dup } then {
        tab_char drop
    } otherwise
    when { = n_char dup } then {
        newline_char drop
    } otherwise
    { 0 exit 1 write_byte_to_stdout print_string "bad char in string: " }
;
se_check_last_defined_function ;

constant "print_string_instruction" {
    lisp_value_stack_push 0
    3drop
    while { > 2dup } {
        dip {
            + 1
            if { = backslash_char read_mem_byte + 2dup } {
                write_byte_to_stdout unescape_string_char read_mem_byte + 2dup
                + 1
            } {
                write_byte_to_stdout read_mem_byte + 2dup
            }
        }
    } # <size> <index> <buffer>
    dip { 0 }
    bi { obj_string_get_size } { obj_string_get_buffer }
    lisp_value_stack_pop
    assert "print-string arg is string" = string_obj_type_id obj_get_type_id lisp_value_stack_peek_top
} ;

constant "make_cell_instruction" {
    lisp_value_stack_push
    drop lisp_value_stack_pop
    alloc_cell lisp_value_stack_peek_top
} ;

constant "cell_get_instruction" {
    lisp_value_stack_push obj_cell_get lisp_value_stack_pop
} ;

constant "cell_set_instruction" {
    lisp_value_stack_push 0
    obj_cell_set swap lisp_value_stack_pop lisp_value_stack_pop
} ;

constant "exit_instruction" {
    lisp_value_stack_push 0
    exit obj_i64_get_value lisp_value_stack_pop
    assert "exit arg is i64" = i64_obj_type_id obj_get_type_id lisp_value_stack_peek_top
} ;

constant "equals_instruction" {
    if { obj_equal lisp_value_stack_pop lisp_value_stack_pop } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
} ;

constant "list_q_instruction" {
    if { obj_is_list lisp_value_stack_pop } {
        lisp_value_stack_push obj_bool_true
    } {
        lisp_value_stack_push obj_bool_false
    }
} ;

def "syscall_pop_i64" {
    obj_i64_get_value lisp_value_stack_pop
    assert "syscall arg is i64" = i64_obj_type_id obj_get_type_id lisp_value_stack_peek_top
} ;

constant "syscall_instruction" {
    lisp_value_stack_push alloc_i64 syscall
    dip {
    dip {
    dip {
    dip {
    dip {
    dip {
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
    }
    syscall_pop_i64
} ;

constant "native_call_instruction" {
    lisp_value_stack_push
    alloc_i64 native_call obj_i64_get_value
    assert "native-call arg is i64" = i64_obj_type_id obj_get_type_id dup
    lisp_value_stack_pop
} ;

constant "read_mem_i64_instruction" {
    lisp_value_stack_push
    alloc_i64 read_mem_i64 obj_i64_get_value
    assert "read-mem-i64 arg is i64" = i64_obj_type_id obj_get_type_id dup
    lisp_value_stack_pop
} ;

constant "write_mem_i64_instruction" {
    lisp_value_stack_push 0
    write_mem_i64 bi@ { obj_i64_get_value }
    assert "write-mem-i64 args are i64" and bi@ { = i64_obj_type_id obj_get_type_id } 2dup
    swap lisp_value_stack_pop lisp_value_stack_pop
} ;

constant "read_mem_byte_instruction" {
    lisp_value_stack_push
    alloc_i64 read_mem_byte obj_i64_get_value
    assert "read-mem-byte arg is i64" = i64_obj_type_id obj_get_type_id dup
    lisp_value_stack_pop
} ;

constant "write_mem_byte_instruction" {
    lisp_value_stack_push 0
    write_mem_byte bi@ { obj_i64_get_value }
    assert "write-mem-byte args are i64" and bi@ { = i64_obj_type_id obj_get_type_id } 2dup
    swap lisp_value_stack_pop lisp_value_stack_pop
} ;

constant "bitwise_ior_instruction" {
    lisp_value_stack_push
    alloc_i64 bit_or bi@ { obj_i64_get_value }
    assert "bitwise-ior args are i64" and bi@ { = i64_obj_type_id obj_get_type_id } 2dup
    swap lisp_value_stack_pop lisp_value_stack_pop
} ;

constant "string_length_instruction" {
    lisp_value_stack_push
    alloc_i64 obj_string_get_size
    assert "string-length arg is string" = string_obj_type_id obj_get_type_id dup
    lisp_value_stack_pop
} ;

constant "string_get_byte_instruction" {
    lisp_value_stack_push
    alloc_i64 read_mem_byte + bi* { obj_string_get_buffer } { obj_i64_get_value } 2dup
    2drop
    assert "string-get-byte: in range" lazy_and { > 2dup } <= 0 over 
    bi* { obj_string_get_size } { obj_i64_get_value } 2dup
    # <string obj> <i64 obj>
    swap lisp_value_stack_pop lisp_value_stack_pop
    assert "string-get-byte second arg is i64" = i64_obj_type_id obj_get_type_id lisp_value_stack_peek 1
    assert "string-get-byte first arg is string" = string_obj_type_id obj_get_type_id lisp_value_stack_peek 0
} ;

constant "lisp_local_env" array_list_new ;

# <symbol> <value>
def "lisp_local_env_add_binding" {
    array_list_append lisp_local_env
    array_list_append lisp_local_env
    swap
} ;

# <env obj> ->
def "lisp_local_env_set_saved_env" {
    array_list_append_all lisp_local_env obj_env_get_bindings
    array_list_clear lisp_local_env
    assert "env object" = env_obj_type_id obj_get_type_id dup
} ;

constant "lisp_plus_symbol" get_or_create_symbol "+" ;
constant "lisp_minus_symbol" get_or_create_symbol "-" ;
constant "lisp_mul_symbol" get_or_create_symbol "*" ;
constant "lisp_div_symbol" get_or_create_symbol "/" ;

constant "lisp_equal_symbol" get_or_create_symbol "equal?" ;
constant "lisp_gt_symbol" get_or_create_symbol ">" ;
constant "lisp_lt_symbol" get_or_create_symbol "<" ;

constant "lisp_define_symbol" get_or_create_symbol "define" ;
constant "lisp_lambda_symbol" get_or_create_symbol "lambda" ;
constant "lisp_if_symbol" get_or_create_symbol "if" ;
constant "lisp_begin_symbol" get_or_create_symbol "begin" ;

constant "lisp_quote_symbol" get_or_create_symbol "quote" ;
constant "lisp_eval_symbol" get_or_create_symbol "eval" ;
constant "lisp_car_symbol" get_or_create_symbol "car" ;
constant "lisp_cdr_symbol" get_or_create_symbol "cdr" ;
constant "lisp_cons_symbol" get_or_create_symbol "cons" ;
symbol_bind lisp_cons_symbol alloc_builtin_func "cons" 2 cons_instruction

constant "lisp_nil_symbol" get_or_create_symbol "nil" ;
symbol_bind lisp_nil_symbol 0 ;

constant "lisp_list_q_symbol" get_or_create_symbol "list?" ;

constant "lisp_list_symbol" get_or_create_symbol "list" ;

constant "lisp_read_syntax_symbol" get_or_create_symbol "read-syntax" ;
constant "lisp_print_symbol" get_or_create_symbol "print" ;
constant "lisp_print_string_symbol" get_or_create_symbol "print-string" ;

constant "lisp_cell_symbol" get_or_create_symbol "cell" ;
constant "lisp_cell_get_symbol" get_or_create_symbol "cell-get" ;
constant "lisp_cell_set_symbol" get_or_create_symbol "cell-set" ;

constant "lisp_exit_symbol" get_or_create_symbol "exit" ;
constant "lisp_syscall_symbol" get_or_create_symbol "syscall" ;
constant "lisp_native_call_symbol" get_or_create_symbol "native-call" ;

constant "lisp_read_mem_i64_symbol" get_or_create_symbol "read-mem-i64" ;
constant "lisp_write_mem_i64_symbol" get_or_create_symbol "write-mem-i64" ;
constant "lisp_read_mem_byte_symbol" get_or_create_symbol "read-mem-byte" ;
constant "lisp_write_mem_byte_symbol" get_or_create_symbol "write-mem-byte" ;

constant "lisp_bitwise_ior_symbol" get_or_create_symbol "bitwise-ior" ;

constant "lisp_string_length_symbol" get_or_create_symbol "string-length" ;
constant "lisp_string_get_byte_symbol" get_or_create_symbol "string-get-byte" ;

# <obj> ->
def "lisp_compile_list"
    when { = lisp_list_q_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car
        obj_pair_cdr
        lisp_program_stack_push list_q_instruction
        assert "list? takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_equal_symbol obj_pair_car dup } then {
        drop
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push equals_instruction
        assert "eq? takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_gt_symbol obj_pair_car dup } then {
        drop
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push obj_i64_gt_instruction
        assert "> takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_lt_symbol obj_pair_car dup } then {
        drop
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push obj_i64_lt_instruction
        assert "< takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_plus_symbol obj_pair_car dup } then {
        drop
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push obj_i64_add_instruction
        assert "+ takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_minus_symbol obj_pair_car dup } then {
        drop
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push obj_i64_sub_instruction
        assert "- takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_mul_symbol obj_pair_car dup } then {
        drop
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push obj_i64_mul_instruction
        assert "* takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_div_symbol obj_pair_car dup } then {
        drop
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push obj_i64_div_instruction
        assert "/ takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_define_symbol obj_pair_car dup } then {
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push 0
        drop
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push define_instruction
        assert "define takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_lambda_symbol obj_pair_car dup } then {
        drop
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push obj_pair_car dup
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push alloc_env array_list_clone lisp_local_env
        lisp_program_stack_push make_lambda_instruction
        obj_pair_cdr
        assert "lambda takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_if_symbol obj_pair_car dup } then {
        drop

        lisp_program_stack_push literal_instruction
        lisp_program_stack_push obj_pair_car dup # else
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push 0 # arg list
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push alloc_env array_list_clone lisp_local_env
        lisp_program_stack_push make_lambda_instruction

        obj_pair_cdr

        lisp_program_stack_push literal_instruction
        lisp_program_stack_push obj_pair_car dup # then
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push 0 # arg list
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push alloc_env array_list_clone lisp_local_env
        lisp_program_stack_push make_lambda_instruction

        obj_pair_cdr

        lisp_compile_expression obj_pair_car dup # compile cond
        lisp_program_stack_push if_instruction
        lisp_program_stack_push call_instruction
        lisp_program_stack_push 0 # arg count
        obj_pair_cdr
        assert "if takes 3 args" = 4 obj_list_length dup
    } otherwise
    when { = lisp_begin_symbol obj_pair_car dup } then {
        drop while { < 0 dup } {
            if { not = 0 dup } {
                lisp_program_stack_push drop_instruction
            } { }
            lisp_compile_expression lisp_value_stack_pop
            + -1
        }
        dip {
            drop while { not = 0 dup } {
                obj_pair_cdr
                lisp_value_stack_push obj_pair_car dup
            }
        }
        obj_list_length dup
        obj_pair_cdr
        assert "begin takes at least 1 arg" < 1 obj_list_length dup
    } otherwise
    when { = lisp_quote_symbol obj_pair_car dup } then {
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push obj_pair_car obj_pair_cdr
        assert "quote takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_eval_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push eval_instruction
        assert "eval takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_cons_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push cons_instruction
        assert "cons takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_car_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push car_instruction
        assert "car takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_cdr_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push cdr_instruction
        assert "cdr takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_cdr_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push cdr_instruction
        assert "cdr takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_list_symbol obj_pair_car dup } then {
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push 0
        drop
        while { not = 0 dup } {
            obj_pair_cdr
            lisp_compile_expression obj_pair_car dup
            lisp_program_stack_push cons_instruction
        }
        obj_pair_cdr
    } otherwise
    when { = lisp_read_syntax_symbol obj_pair_car dup } then {
        lisp_program_stack_push read_syntax_instruction
        assert "read-syntax takes no args" = 1 obj_list_length
    } otherwise
    when { = lisp_print_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push print_instruction
        assert "print takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_print_string_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push print_string_instruction
        assert "print-string takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_cell_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push make_cell_instruction
        assert "cell takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_cell_get_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push cell_get_instruction
        assert "cell-get takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_cell_set_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        lisp_program_stack_push cell_set_instruction
        obj_pair_cdr
        assert "cell-set takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_exit_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push exit_instruction
        assert "exit takes 1 args" = 2 obj_list_length dup
    } otherwise
    when { = lisp_syscall_symbol obj_pair_car dup } then {
        drop
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push syscall_instruction
        assert "syscall takes 7 args" = 8 obj_list_length dup
    } otherwise
    when { = lisp_native_call_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push native_call_instruction
        assert "native-call takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_read_mem_i64_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push read_mem_i64_instruction
        assert "read-mem-i64 takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_write_mem_i64_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push write_mem_i64_instruction
        assert "write-mem-i64 takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_read_mem_byte_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car obj_pair_cdr
        lisp_program_stack_push read_mem_byte_instruction
        assert "read-mem-byte takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_write_mem_byte_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push write_mem_byte_instruction
        assert "write-mem-byte takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_bitwise_ior_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push bitwise_ior_instruction
        assert "bitwise-ior takes 2 args" = 3 obj_list_length dup
    } otherwise
    when { = lisp_string_length_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car
        obj_pair_cdr
        lisp_program_stack_push string_length_instruction
        assert "stirng-length takes 1 arg" = 2 obj_list_length dup
    } otherwise
    when { = lisp_string_get_byte_symbol obj_pair_car dup } then {
        lisp_compile_expression obj_pair_car
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup
        obj_pair_cdr
        lisp_program_stack_push string_get_byte_instruction
        assert "stirng-get-byte takes 2 args" = 3 obj_list_length dup
    } otherwise
    {
        drop
        while { not = 0 dup } {
            obj_pair_cdr
            lisp_compile_expression obj_pair_car dup # compile arg expressions
        }
        obj_pair_cdr
        lisp_compile_expression obj_pair_car dup # push lambda generation code
        lisp_program_stack_push call_instruction
        lisp_program_stack_push + -1 obj_list_length dup # push arg count
    }
;

# <obj> ->
def "lisp_compile_expression_switch" 
    when { obj_is_list dup } then {
        lisp_compile_list
    } otherwise
    when { = symbol_obj_type_id obj_get_type_id dup } then {
        if { symbol_has_binding dup } {
            lisp_program_stack_push literal_instruction
            lisp_program_stack_push symbol_get_binding
        } {
            exit 1
            print_newline
            print_obj
            print_string "undefined symbol: "
        }
    } otherwise
    {
        lisp_program_stack_push literal_instruction
        lisp_program_stack_push
    }
;

# <obj> <local env> ->
def "lisp_compile_expression" {
    drop lisp_value_stack_pop
    lisp_compile_expression_switch
    lisp_value_stack_push dup
    assert "obj type id is OK" and bi { <= 0 } { >= 7 } obj_get_type_id dup
} ;

# -> # expects expression to be on the top of lisp_value_stack
def "lisp_eval" {
    while { not array_list_is_empty lisp_program_stack } {
        call lisp_program_stack_pop
    }
    lisp_compile_expression lisp_value_stack_pop
} ;


def "define_instruction_func" { call define_instruction } ;
se_check_last_defined_function ;
def "call_instruction_func" { call call_instruction } ;
# se_check_last_defined_function ;
def "make_cell_instruction_func" { call make_cell_instruction } ;
se_check_last_defined_function ;

def "read_mem_i64_instruction_func" { call read_mem_i64_instruction } ;
se_check_last_defined_function ;
def "read_mem_byte_instruction_func" { call read_mem_byte_instruction } ;
se_check_last_defined_function ;
def "write_mem_i64_instruction_func" { call write_mem_i64_instruction } ;
se_check_last_defined_function ;
def "write_mem_byte_instruction_func" { call write_mem_byte_instruction } ;
se_check_last_defined_function ;
def "bitwise_ior_instruction_func" { call bitwise_ior_instruction } ;
se_check_last_defined_function ;
def "print_string_instruction_func" { call print_string_instruction } ;
se_check_last_defined_function ;

se_check_function_by_name "call_lambda" ;
se_check_function_by_name "symbol_bind" ;
#se_enable ;
se_check_function_by_name "lisp_compile_expression" ;
#se_disable ;
se_check_function_by_name "lisp_gc_push_roots_to_stack" ;
se_check_function_by_name "read_next_expression" ;




#while { true } { print_newline token_print read_next_token } ;
#while { true } { print_newline print_obj lisp_value_stack_pop read_next_expression } ;
while { true } { assert "value stack is empty" array_list_is_empty lisp_value_stack drop lisp_value_stack_pop lisp_eval read_next_expression } ;

