# import lib.2s
# import allocator.2s

constant "buffered_stdin_buffer_size" 4000 ;
constant "buffered_stdin_buffer" malloc buffered_stdin_buffer_size ;
constant "buffered_stdin_struct_size" * 2 8 ;
constant "buffered_stdin_struct" malloc buffered_stdin_struct_size ;


# pos points to next available byte or (exclusive) is equal to cap, cap points to next unavailable byte

def "buffered_stdin_pos" {
    read_mem_i64 buffered_stdin_struct
} ;

def "buffered_stdin_set_pos" {
    write_mem_i64 buffered_stdin_struct
} ;

def "buffered_stdin_cap" {
    read_mem_i64 + 8 buffered_stdin_struct
} ;

def "buffered_stdin_set_cap" {
    write_mem_i64 + 8 buffered_stdin_struct
} ;

buffered_stdin_set_pos 0 ;
buffered_stdin_set_cap 0 ;

def "buffered_stdin_ensure_next_byte_availability" {
    if { = buffered_stdin_pos buffered_stdin_cap } {
        buffered_stdin_set_cap
        assert "no EOF in stdin" not = 0 dup
        panic_on_syscall_error syscall_read 0 buffered_stdin_buffer buffered_stdin_buffer_size
        buffered_stdin_set_pos 0
    } { }
    assert "stdin buffer invariant cap <= buffer size" <= buffered_stdin_cap buffered_stdin_buffer_size
    assert "stdin buffer invariant pos <= cap" <= buffered_stdin_pos buffered_stdin_cap
    assert "stdin buffer invariant 0 <= pos" <= 0 buffered_stdin_pos
} ;

# -> <byte>
def "buffered_stdin_read_byte" {
    buffered_stdin_set_pos + 1 buffered_stdin_pos
    read_mem_byte + buffered_stdin_pos buffered_stdin_buffer
    buffered_stdin_ensure_next_byte_availability
} ;


while { true } {
    write_byte_to_stdout buffered_stdin_read_byte
} ;
