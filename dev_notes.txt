!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!! TIME TRACKING !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Архитектура
  - Минимальное ядро - писать на ассемблере как можно меньше, парсер тоже на форте надо написать
  - интерпретатор выполняет Read-Eval-Loop
  - инструкции идут в обратном порядке чтобы можно было писать на "форте" в ассемблере

План
    + написать интерпретатор, threaded code
    + заменить инструкции exit и write_buffer на syscall и функции
    + добавить проверку на overflow и underflow для обоих стеков
    + заменить i_rjmp на обычный i_jmp
    + parse i64 (a 1 hour 10 min)
        + '=', '+', '-', '<', '>'
        + and
        + while (prediction 30 min, actual 3 hours)
            + jmp_if (prediction 10 min, actual 15 min) - BUG!
        + dup-n (actual 10 min)
    + byte_array ()
        + malloc/free (p 10-20 min, actual 50 min, I thought that malloc was implemented)
            + i_rot, i_rev_rot
        + simple error logging for syscalls (p 5 min, a 30 min)
        + byte_array (p 1 hour, a 1 hour 20 min)
            + make_byte_array (~ 5 min)
                + check args
            + byte_array_pointer (~ 2 min)
            + byte_array_size (~ 3 min)
            + byte_array_get (~ 15 min )
                + i_read_mem_byte (a 7 min)
                + range check, panic
                    + i_2dup
                + i_or
            + byte_array_set (~5 min)
                + i_write_mem_byte
                + range check, panic
            + write_byte_array_to_std (~ 5 min)
            + test (~15 min)
    + print i64 (p 50 min, a 1 hour 40 min)
        + i64_str_size (p 20 min, a 40 min)
            + i_div
            + i_mod
        + write_i64_to_buffer (p 30 min, a 1 hour)
            + i_over
            + check size (p 8 min)
            + print minus (p 3 min)
            + print digits (negate number if positive) (p 15 min)
    + print_number funciton (p 5 min, a 7 min)
    + print stack (30 min, a 25 min)
        + i_stack_depth (5 min, 8 min #idiv problem, it doesn't support immediate values)
        + function (15 min, a 16 min)
            + print_byte
    - lexer
        + design sketch #1 (p 20 min, a 30)
        # splits input into tokens (token_type - string pairs)
        # reads one token per call !!!!
        # returns token type and string
        # save line and column numbers for error reporting?
        > tokens
            # whitespace is delimiter except in string literals
            > ';'
            > '}'
            > '{'
            > string literal
                # escape sequences ('\n', '\t')
                # string literal cannot be on multiple lines
            > number literal
            > word
                # "2dup" word is allowed
            > error?
                # bad string literals?
        + growable byte buffer
            + realloc (p 20 min, a 25)
            + rewrite byte buffer (p 45 min, a 1 hour 30 min)
                # size
                # capacity
                # pointer
                + make (p 10 min, a 9 min)
                + size  (p 5 min, a 2 min)
                + set  (p 5 min, a 4 min)
                --- ensure_capacity (p 10 min) 5 min + 10 min
                    - i_bit_lshift (p 8)
                        - no such instruction
                    - i_bit_or (p 8)
                    #scratch this
                + append  (p 10 min, 23 min)
                + pointer (p 3 min, a 3 min)
                + destroy (p 8 min, a 4 min)
                + test & debug    (p 8 min, a 25 min)
                    + make fix (9 min)
            -? grow <n> # returns pointer to the new slice
        + scanner # 1 byte lookahead scanner (p 20, a 13 min)
            # keep the byte on stack ?
            # interpreter state ?
            # closures, function generation, append_function_args?
            # just keep it on the heap !
            + scanner_make (p 5)
                # allocates memory and reads first byte
            + scanner_peek (p 10)
                # returns cached value
            + scanner_advance (p 5)
                # reads stdin
        + next_token
            # parses next token and returns <byte vector>
            + next_token_number_or_word
            + skip_whitespace (p 15 min, a 15 min)
                # skips ' ', '\t', '\n', '\r'
            + test / token printer (p 10 min, a 11 min)
            + skip_comment (p 10 min, a 25 min)
                - skip_comments_and_whitespace
            + rewrite next_token (p 15 min, a 2 min)
            + string literal handling in next_token (p 20 min, a 28 min)
        - token types
            # 0 number
            # 1 string literal
            # 2 word
            # 3 {
            # 4 }
            # 5 ;
            - is_number_token (p 30 min)
    + test byte vector on large strings (p 10 min, a 10 min)
    + fix byte vector on large strings (p 30 min, a 29 min)
    - parser
    - codegen
    - написать интерпретатор 2s
    - b-tree
        # lazy maintenance
  - conservative GC: simple and inefficient
    - интерпретатор генерирует код, который делает tail-call в него
  - conservative GC
    - cuckoo hashing
  - статическая проверка операций с return стеком
  - статическая проверка типов, вывод stack effect
    - optional args

  - интерпретатор лиспа
    - компиляция в виртуальную машину форта
  - оптимизирующий компилятор лиспа (SSA, coloring, lambda calculus?)
    - сначала написать ассемблер
    - jit


API:
    - malloc n
        # Allocates n + 8 bytes internally. Saves size in the first 8
        # bytes. Returns addr + 8.
    - free a
        # Reads size from addr - 8. Deallocates memory addr - 8.
    - make_byte_array n
        # allocates a byte array. returns pointer to the array
        # array memory layout: [<size i64> <byte>...]

not unrgent, maybe important:
  - i_peek_ret_stack: check for non-positive arg


Разное


def не позволяет легко определить переменную (значение), нужен def-val?
'if' function is terrible

идеи:

- types: (number, bool)
- test harness in 2s (instead of bash)
- literal arrays with commas
- recursive descent for parser and lexer?
- look at how c works with signal handlers
- named stack vars, print stack states for functions
- stack allocation, frame pointer
- function pointer indirection for JIT
- использовать late-binding чтобы работала рекурсия
- оставлять тексты определение функций в словаре для late-binding
- tail-call optimisation
  - все функции линейные, нет control flow
- interpreter state pointer
!- function suggestion by type, через алгоритм Дейкстры
- boxed types
- sigsegv handler for stack guard and stack trace
- set_type function


linux syscall args [ %rdi, %rsi, %rdx, %r10, %r8, %r9 ]


// <number> -> <number>
def "i64_str_size" {

}
// <number> <buffer> <buffer_size>
def "i64_to_str" {

}


// atoi function
// <char index> <number> <buffer> <string size>

str_char(n, string) - n-th char

str_size "123"      | 3
str_char "123" 1    | '2'

def "atoi" {
    drop swap
    drop swap
    if {
        =
            45
            str_char 0 dup-n 2
        } { * -1 } { }
    drop
    while {
        not or
                =
                    dup-n 3 // char index
                    dup-n 5 // string size
                or
                    < 57
                    swap
                    > 48
                    dup str_char dup-n 2 dup-n 3
    } {
        + 1 // increment index
        swap
        +
            -
                str_char dup-n 4 dup-n 5
                48
            * 10
        swap
    }
    0 0
    if {
        =
            45
            str_char dup-n 2 dup-n 3
        } { + 1 } { }

};

// <string>
def "atoi-fun" {
    fold_left {+ * 10}
    map {- '0'}
    take_while {and >= '0' swap <= '9' dup }
    string_to_vec
};
