Архитектура
  - Минимальное ядро - писать на ассемблере как можно меньше, парсер тоже на форте надо написать
  - интерпретатор выполняет Read-Eval-Loop
  - инструкции идут в обратном порядке чтобы можно было писать на "форте" в ассемблере

План
  + написать интерпретатор, threaded code
  + заменить инструкции exit и write_buffer на syscall и функции
  + добавить проверку на overflow и underflow для обоих стеков
  + заменить i_rjmp на обычный i_jmp
  - i_peek_ret_stack: check for non-positive arg
  - сделать кучу
  - check syscall return codes
  - написать интерпретатор 2s
    - check end of execution in i_return
  - conservative GC
    - cuckoo hashing
  - статическая проверка операций с return стеком
  - статическая проверка типов, вывод stack effect
    - optional args
  - test harness in 2s (instead of bash)
  
  - интерпретатор лиспа
    - компиляция в виртуальную машину форта
  - оптимизирующий компилятор лиспа (SSA, coloring, lambda calculus?)
    - jit

Разное


def не позволяет легко определить переменную (значение), нужен def-val?
'if' function is terrible

идеи:

- использовать late-binding чтобы работала рекурсия
- оставлять тексты определение функций в словаре для late-binding
- tail-call optimisation
  - все функции линейные, нет control flow
- interpreter state pointer
- function suggestion by type, через алгоритм Дейкстры
- boxed types
- sigsegv handler for stack guard and stack trace
- set_type function


linux syscall args [ %rdi, %rsi, %rdx, %r10, %r8, %r9 ]


// atoi function
// <str pointer> <number> <string>

str_size(string) - string size
str_char(string, n) - n-th char

str_size "123"      | 3
str_char "123" 1    | '2'

def "atoi" {
    drop-n 3 swap-n 3 dup-n 2 
    while { 
        not and 
            = 
                str_char dup-n 4 dup-n 5 
                str_size dup-n 4 
            and 
                < str_char dup-n 3 dup-n 4 48 
                < str_char dup-n 2 dup-n 3 48 
    } { 
        drop swap-n 2
        + 
            * 10 dup-n 3 
            - str_char dup-n 3 dup-n 4 48
        drop swap-n 1
        + 1 dup-n 1 
    } 0 0
};

// <string>
def "atoi-fun" {
    fold_left {+ * 10}
    map {- '0'}
    take_while {and >= '0' swap <= '9' dup }
    string_to_vec
};
