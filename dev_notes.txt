!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!! TIME TRACKING !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Архитектура
  - Минимальное ядро - писать на ассемблере как можно меньше, парсер тоже на форте надо написать
  - интерпретатор выполняет Read-Eval-Loop
  - инструкции идут в обратном порядке чтобы можно было писать на "форте" в ассемблере

План
    + написать интерпретатор, threaded code
    + заменить инструкции exit и write_buffer на syscall и функции
    + добавить проверку на overflow и underflow для обоих стеков
    + заменить i_rjmp на обычный i_jmp
    + parse i64 (a 1 hour 10 min)
        + '=', '+', '-', '<', '>'
        + and
        + while (prediction 30 min, actual 3 hours)
            + jmp_if (prediction 10 min, actual 15 min) - BUG!
        + dup-n (actual 10 min)
    + byte_array ()
        + malloc/free (p 10-20 min, actual 50 min, I thought that malloc was implemented)
            + i_rot, i_rev_rot
        + simple error logging for syscalls (p 5 min, a 30 min)
        + byte_array (p 1 hour, a 1 hour 20 min)
            + make_byte_array (~ 5 min)
                + check args
            + byte_array_pointer (~ 2 min)
            + byte_array_size (~ 3 min)
            + byte_array_get (~ 15 min )
                + i_read_mem_byte (a 7 min)
                + range check, panic
                    + i_2dup
                + i_or
            + byte_array_set (~5 min)
                + i_write_mem_byte
                + range check, panic
            + write_byte_array_to_std (~ 5 min)
            + test (~15 min)
    + print i64 (p 50 min, a 1 hour 40 min)
        + i64_str_size (p 20 min, a 40 min)
            + i_div
            + i_mod
        + write_i64_to_buffer (p 30 min, a 1 hour)
            + i_over
            + check size (p 8 min)
            + print minus (p 3 min)
            + print digits (negate number if positive) (p 15 min)
  - написать интерпретатор 2s
  - conservative GC: simple and inefficient
    - интерпретатор генерирует код, который делает tail-call в него
  - conservative GC
    - cuckoo hashing
  - статическая проверка операций с return стеком
  - статическая проверка типов, вывод stack effect
    - optional args

  - интерпретатор лиспа
    - компиляция в виртуальную машину форта
  - оптимизирующий компилятор лиспа (SSA, coloring, lambda calculus?)
    - сначала написать ассемблер
    - jit


API:
    - malloc n
        # Allocates n + 8 bytes internally. Saves size in the first 8
        # bytes. Returns addr + 8.
    - free a
        # Reads size from addr - 8. Deallocates memory addr - 8.
    - make_byte_array n
        # allocates a byte array. returns pointer to the array
        # array memory layout: [<size i64> <byte>...]

not unrgent, maybe important:
  - i_peek_ret_stack: check for non-positive arg


Разное


def не позволяет легко определить переменную (значение), нужен def-val?
'if' function is terrible

идеи:

- test harness in 2s (instead of bash)
- literal arrays with commas
- recursive descent for parser and lexer?
- look at how c works with signal handlers
- named stack vars, print stack states for functions
- stack allocation, frame pointer
- function pointer indirection for JIT
- использовать late-binding чтобы работала рекурсия
- оставлять тексты определение функций в словаре для late-binding
- tail-call optimisation
  - все функции линейные, нет control flow
- interpreter state pointer
!- function suggestion by type, через алгоритм Дейкстры
- boxed types
- sigsegv handler for stack guard and stack trace
- set_type function


linux syscall args [ %rdi, %rsi, %rdx, %r10, %r8, %r9 ]


// <number> -> <number>
def "i64_str_size" {

}
// <number> <buffer> <buffer_size>
def "i64_to_str" {

}


// atoi function
// <char index> <number> <buffer> <string size>

str_char(n, string) - n-th char

str_size "123"      | 3
str_char "123" 1    | '2'

def "atoi" {
    drop swap
    drop swap
    if {
        =
            45
            str_char 0 dup-n 2
        } { * -1  } { }
    drop
    while {
        not or
                =
                    dup-n 3 // char index
                    dup-n 5 // string size
                or
                    < 57
                    swap
                    > 48
                    dup str_char dup-n 2 dup-n 3
    } {
        + 1 // increment index
        swap
        +
            -
                str_char dup-n 4 dup-n 5
                48
            * 10
        swap
    }
    0 0
    if {
        =
            45
            str_char dup-n 2 dup-n 3
        } { + 1 } {}

};

// <string>
def "atoi-fun" {
    fold_left {+ * 10}
    map {- '0'}
    take_while {and >= '0' swap <= '9' dup }
    string_to_vec
};
