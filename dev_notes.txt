Архитектура
  - Минимальное ядро - писать на ассемблере как можно меньше, парсер тоже на форте надо написать
  - интерпретатор выполняет Read-Eval-Loop
  - инструкции идут в обратном порядке чтобы можно было писать на "форте" в ассемблере

План
  + написать интерпретатор, threaded code
  + заменить инструкции exit и write_buffer на syscall и функции
  + добавить проверку на overflow и underflow для обоих стеков
  + заменить i_rjmp на обычный i_jmp
  - parse i64
    + '=', '+', '-', '<', '>'
    - while
    - dup-n
    - str_char
    - and
  - print i64
  - сделать кучу
  - check syscall return codes
  - conservative GC
    - cuckoo hashing
  - написать интерпретатор 2s
    - интерпретатор генерирует код, который делает tail-call в него
  - статическая проверка операций с return стеком
  - статическая проверка типов, вывод stack effect
    - optional args
  - test harness in 2s (instead of bash)
  
  - интерпретатор лиспа
    - компиляция в виртуальную машину форта
  - оптимизирующий компилятор лиспа (SSA, coloring, lambda calculus?)
    - сначала написать ассемблер
    - jit

not unrgent, maybe important:
  - i_peek_ret_stack: check for non-positive arg


Разное


def не позволяет легко определить переменную (значение), нужен def-val?
'if' function is terrible

идеи:

- function pointer indirection for JIT
- использовать late-binding чтобы работала рекурсия
- оставлять тексты определение функций в словаре для late-binding
- tail-call optimisation
  - все функции линейные, нет control flow
- interpreter state pointer
!- function suggestion by type, через алгоритм Дейкстры
- boxed types
- sigsegv handler for stack guard and stack trace
- set_type function


linux syscall args [ %rdi, %rsi, %rdx, %r10, %r8, %r9 ]


// atoi function
// <char index> <number> <buffer> <string size>

str_char(n, string) - n-th char

str_size "123"      | 3
str_char "123" 1    | '2'

def "atoi" {
    drop swap
    drop swap
    drop
    while {
        not and
                =
                    dup-n 3 // char index
                    dup-n 5 // string size
                and
                    < 57
                    swap
                    > 48
                    dup str_char dup-n 2 dup-n 3
    } { 
        + 1 // increment index
        swap
        + 
            -
                str_char dup-n 4 dup-n 5
                48
            * 10
        swap
    }
    0
    if { // '-asfasf' case is not handled
        =
            45
            str_char dup-n 2 dup-n 3
        } { -1 } { 0 }
};

// <string>
def "atoi-fun" {
    fold_left {+ * 10}
    map {- '0'}
    take_while {and >= '0' swap <= '9' dup }
    string_to_vec
};
